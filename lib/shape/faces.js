"use strict";exports.__esModule=true;exports.Faces=void 0;var _math=require("../utils/math");var _face=require("./face");var _triangulator=require("./utils/triangulator");var _facewinder=require("./utils/facewinder");var _mesh=require("../mesh/mesh");var _watcher=require("../utils/watcher");var _validator=require("../utils/validator");const{validate}=new _validator.Validator("Faces");class Faces extends Array{constructor(faces,mesh=null){validate({mesh,Mesh:_mesh.Mesh});const triangulatedFaces=[];for(const face of faces){if(face.length==3){triangulatedFaces.push(new _face.Face(face,mesh));continue}const triangulator=new _triangulator.Triangulator(face,mesh);triangulatedFaces.push(...triangulator.toFaces(mesh))}super(...triangulatedFaces);this.mesh=mesh}static get[Symbol.species](){return Array}get area(){const value=this.reduce((sum,{area})=>(0,_math.add)(sum,Number(area)),0);return(0,_math.toMeters)(value)}computeNormals(){const{faces}=new _facewinder.Facewinder(this)}toString(){return JSON.stringify(this.map(f=>f.toString()))}}exports.Faces=Faces;