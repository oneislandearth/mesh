{"version":3,"sources":["../../src/shape/face.js"],"names":["validate","Validator","Face","Array","constructor","a","b","c","mesh","species","Symbol","index","Error","Number","faces","findIndex","face","equals","vertices","plane","normal","Direction","scalar","Plane","vertexNormals","edges","Edge","center","Point","area","adjacentFaces","findAdjacentFaceFromEdgeIndex","edgeIndex","i0","i1","i2","faceIndex","edgeCheck","indexOf","otherCheck","pointsAbove","height","planes","map","missingAdjacentIndex","v","vertexIndex","vertex","Object","entries","point","facePlane","clone","adjacentPlane","previousAdjacentPlane","length","scale","pointOfIntersectionWithPlanes","containsVertex","fac","contains","push","array","fill","i","listOfFirstElements","slice","result","loop1","element","listOfSecondElements","loop2","el","listOfThirdElements","epsilon","angleBetweenNormals","Math","sqrt","pow","direction","loop3","l","resultPlane1","resultPlane2","resultPlane3","dihedrals","adjacentFace","angle","dihedral","pi","type","projectedNormal","radials","normals","radial","update","flip","toString","JSON","stringify","match","find","Boolean"],"mappings":"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","sourcesContent":["// Import the required math functions\nimport { divide, add, subtract, norm, cross, dot, toMeters, epsilon, pi, acos, multiply, unit, tan, angleBetween, isZeroes } from '@oneisland/math';\n\n// Import the range function\n// import { range } from 'utils/range_array.js';\n\n// Import the required geometry modules\nimport { Plane } from 'geometry/plane';\nimport { Point } from 'geometry/point';\n\n// Import the required geometry utilities\nimport { Direction } from 'geometry/utils/direction';\n\n// Import the required shape modules\nimport { Edge } from 'shape/edge';\n\n// Imoprt point in polygon function\n// Import { pointInsideTetrahedron } from 'point_inside_tetrahedron.js';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Face');\n\n// Define a class face which is an array of three vertices plus extra properties\nexport class Face extends Array {\n\n  // Bind the indices to the mesh and any mesh\n  constructor([a, b, c], mesh = null) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Throw an error if the mesh in not a Mesh\n    validate({ mesh }, 'Mesh');\n\n    // Call the super function to bind our indices\n    super(a, b, c);\n\n    // Bind the reference to the current mesh if there is one\n    this.mesh = mesh;\n  }\n\n  // Define the species\n  get species() {\n  \n    // Define the species as 'Face'\n    return 'Face';\n  }\n\n  // Define the species to be an array\n  static get [Symbol.species]() {\n    return Array; \n  }\n\n  // Find the index of the face in the mesh faces\n  get index() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the index - the face is not bound to a Mesh`);\n\n    // Return the index of the face in the faces\n    return Number(this.mesh.faces.findIndex(face => face.equals(this)));\n  }\n\n  // Compute the value of vertex a\n  get a() {\n    return this.vertices[0];\n  }\n\n  // Compute the value of vertex b\n  get b() {\n    return this.vertices[1];\n  }\n\n  // Compute the value of vertex c\n  get c() {\n    return this.vertices[2];\n  }\n\n  // Find the vertices for the face based on the indices\n  get vertices() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);\n\n    // Return the vertices based on the indices\n    return [this.mesh.vertices[this[0]], this.mesh.vertices[this[1]], this.mesh.vertices[this[2]]];  \n  }\n\n  // Find the Plane from a face\n  get plane() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);\n\n    // Calculate the normal of the Plane\n    const normal = new Direction(cross(subtract(this.a, this.b), subtract(this.c, this.b)));\n\n    // Calculate the scalar of the Plane\n    const scalar = dot(normal, this.a);\n\n    // Return the Plane from the Face\n    return new Plane({ normal, scalar });\n  }\n\n  // Compute the normal of the face\n  get normal() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);\n\n    // Return the normal for the face\n    return this.plane.normal;\n  }\n  \n  // Compute the vertex normals\n  get vertexNormals() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertex normals of the face - the face is not bound to a Mesh`);\n  }\n\n  // Find the edges from the face\n  get edges() {\n\n    // Return the edges in the face (ab, bc, ca)\n    return [new Edge([this[0], this[1]], this.mesh), new Edge([this[1], this[2]], this.mesh), new Edge([this[2], this[0]], this.mesh)];\n  }\n\n  // Compute the center of a face\n  get center() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);\n\n    // Calculate the center of the face\n    return new Point(divide(add(this.a, this.b, this.c), 3));\n  }\n\n  // Compute the area of a mesh\n  get area() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);\n  \n    // Calculate the area of a triangle = norm(cross product(a-b, a-c))\n    return toMeters(divide(norm(cross(subtract(this.a, this.b), subtract(this.a, this.c))), 2));\n  }\n\n  // Find the adjacent faces to the face\n  get adjacentFaces() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);\n\n    // Return the list of adjacent faces\n    return [\n      \n      // Find face at edge ab/ba\n      this.findAdjacentFaceFromEdgeIndex(0), \n      \n      // Find face at edge bc/cb\n      this.findAdjacentFaceFromEdgeIndex(1),\n\n      // Find face at edge ca/ac\n      this.findAdjacentFaceFromEdgeIndex(2)];\n  }\n\n  // Find an adjacent face from an edge index (0: ab, 1: bc, 2: ca)\n  findAdjacentFaceFromEdgeIndex(edgeIndex) {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent face fom the edge index - the face is not bound to a Mesh`);\n\n    // Determine the vertex which make up the edge\n    const i0 = (edgeIndex);\n    const i1 = ((edgeIndex + 1) % 3);\n\n    // Determine the vertex which is not part of the edge\n    const i2 = ((edgeIndex + 2) % 3);\n\n    // Find the index of the adjacent face\n    const faceIndex = this.mesh.faces.findIndex(face => {\n      \n      // Check that the face contains i0 and i1 (the edge)\n      const edgeCheck = (~face.indexOf(this[i0]) && ~face.indexOf(this[i1]));\n\n      // Check that the face doesn't contain the current index (same face)\n      const otherCheck = (face.indexOf(this[i2]) == -1);\n\n      // Return true if the face is an adjacent face\n      return (edgeCheck && otherCheck);\n    });\n\n    // Return null if there is no face / face index, or return the face\n    return (~faceIndex) ? this.mesh.faces[faceIndex] : null;\n  }\n\n  // // Find the face a specific distance above\n  // pointsAbove(distance) {\n\n  //   // Throw an error if distance is not a Number\n  //   validate({ distance }, 'Number');\n\n  //   // Create a list of planes (face, faceAB, faceBC, faceCA)\n  //   const planes = [this.plane.clone(), ...this.adjacentFaces.map(face => ((face) ? face.plane.clone() : null))];\n\n  //   // Scale each of the planes by the distance\n  //   for (const i in planes) {\n\n  //     // Check if there is a plane and scale it by the distance\n  //     if (planes[i]) planes[i].scale(distance);\n  //   }\n\n  //   // Find the index of the non-existing adjacent face if there is one\n  //   const missingAdjacentIndex = this.adjacentFaces.findIndex(v => v === null);\n\n  //   // Check if there is a missing face\n  //   if (~missingAdjacentIndex) {\n\n  //     // Define which vertex from the edge to use based on which adjacent face is missing (0, 1, 2 == 2, 1, 0)\n  //     const vertexIndex = (missingAdjacentIndex == 0) ? 2 : (missingAdjacentIndex == 2) ? 0 : missingAdjacentIndex;\n\n  //     // Creates a new plane that is parallel to the xz plane and contains one point of the edge\n  //     planes[1 + missingAdjacentIndex] = new Plane({\n        \n  //       // Calculate the normal\n  //       normal: new Direction([0, 1, 0]), \n        \n  //       // Calculate the scalar based on the edge\n  //       scalar: dot([0, 1, 0], this.vertices[vertexIndex])\n  //     });\n  //   }\n\n  //   // Extract each of the planes\n  //   const [planeFace, planeFaceAB, planeFaceBC, planeFaceCA] = planes;\n\n  //   // Finds the three lines of intersection between the original face and the three planes\n  //   // const lineAB = planeFace.lineOfIntersectionWith(planeFaceAB);\n  //   // const lineBC = planeFace.lineOfIntersectionWith(planeFaceBC);\n  //   // const lineCA = planeFace.lineOfIntersectionWith(planeFaceCA);\n\n  //   // Finds the three points of intersection between the three lines\n  //   // const pointA = lineAB.pointOfIntersectionWithLine(lineCA);\n  //   // const pointB = lineBC.pointOfIntersectionWithLine(lineAB);\n  //   // const pointC = lineCA.pointOfIntersectionWithLine(lineBC);\n\n  //   // Find the point of intersection between three faces\n  //   const pointA = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceCA);\n  //   const pointB = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceBC);\n  //   const pointC = planeFace.pointOfIntersectionWithPlanes(planeFaceBC, planeFaceCA);\n\n  //   // Return three points above\n  //   return [pointA, pointB, pointC];\n  // }\n\n  // Updated face above method, deals with coplanar faces\n\n  // Takes in a face and outputs the points above it, whether the faces surrounding it are coplanar or not\n  pointsAbove(height) {\n\n    // Define the array that will contain the points above the face\n    const pointsAbove = [];\n\n    // Create a list of planes (faceAB, faceBC, faceCA)\n    const planes = this.adjacentFaces.map(face => ((face) ? face.plane : null));\n\n    // Find the index of the non-existing adjacent face if there is one\n    const missingAdjacentIndex = planes.findIndex(v => v === null);\n\n    // Check if there is a missing face\n    if (~missingAdjacentIndex) {\n\n      // Define which vertex from the edge to use based on which adjacent face is missing (0, 1, 2 == 2, 1, 0)\n      const vertexIndex = (missingAdjacentIndex == 0) ? 2 : (missingAdjacentIndex == 2) ? 0 : missingAdjacentIndex;\n\n      // Creates a new plane that is parallel to the xz plane and contains one point of the edge\n      planes[missingAdjacentIndex] = new Plane({\n        \n        // Calculate the normal\n        normal: new Direction([0, 1, 0]), \n        \n        // Calculate the scalar based on the edge\n        scalar: dot([0, 1, 0], this.vertices[vertexIndex])\n      });\n    }\n    \n    // Iterate through each vertex in the face\n    for (const [index, vertex] of Object.entries(this.vertices)) {\n\n      // Define the a variable that is the point that will be returned\n      let point = [];\n\n      // Extract the current face plane\n      const facePlane = this.plane.clone();\n\n      // Current adjacent face plane normal\n      const adjacentPlane = planes[index].clone();\n\n      // Previous adjacent face plane\n      const previousAdjacentPlane = planes[(index + (this.vertices.length - 1)) % this.vertices.length].clone();\n\n      // Calculate the cross products\n      // console.log(`\\ncross(\\n\\tadjacent: ${adjacentPlane}, \\n\\tprevious: ${previousAdjacentPlane}\\n)`); \n      // console.log(`${cross(adjacentPlane.normal, previousAdjacentPlane.normal)}`);\n      // console.log(`\\ncross(\\n\\tface: ${facePlane}, \\n\\tprevious: ${previousAdjacentPlane}\\n)`); \n      // console.log(`${cross(facePlane.normal, previousAdjacentPlane.normal)}`);\n      // console.log(`\\ncross(\\n\\tadjacent: ${adjacentPlane}, \\n\\tface: ${facePlane}\\n)`); \n      // console.log(`${cross(adjacentPlane.normal, facePlane.normal)}`);\n      // console.log('count')\n\n      // Checks if the three planes are not parallel, if that is the case compute the normals as per usual\n      if (\n        (!isZeroes(cross(adjacentPlane.normal, previousAdjacentPlane.normal))) && \n        (!isZeroes(cross(facePlane.normal, previousAdjacentPlane.normal))) && \n        (!isZeroes(cross(adjacentPlane.normal, facePlane.normal)))\n      ) {\n\n        // Log out the case\n        // console.log('points above case one');\n\n        // Scale the three planes\n        facePlane.scale(height);\n        previousAdjacentPlane.scale(height);\n        adjacentPlane.scale(height);\n\n        // Calculate the three plane intersection on the three planes\n        point = facePlane.pointOfIntersectionWithPlanes(adjacentPlane, previousAdjacentPlane);\n\n      // If any two of the three faces are parallel, we try to find three faces that contain the vertex that are not parellel. If this fails, we have a point surrounded by parallel faces,\n      // so we return the point plus the height times the normal of the original face, so the point is directly above where it was by a distance of height.\n      } else {\n\n        // Describe the method\n        // console.log('points above case two');\n\n        // A list of the faces that contain the vertex\n        const containsVertex = [];\n\n        // Find all the faces that contain the vertex\n        for (const fac of this.mesh.faces) {\n\n          // Fac has to be different than the original face\n          if (!fac.equals(this)) {\n\n            // Fac must contain vertex\n            if (fac.contains(vertex)) {\n\n              // Add to the list of faces that contain the vertex\n\n              containsVertex.push(fac);\n              \n            }\n          }\n        }\n\n        // Iterate through the faces and find if there are a combination of three that are not parallel.\n\n        // Essentially we need to compute whats known in mathematics as a combination, or n choose r, where n\n        // is the number of things we are choosing from and r is the size of the combination. For this case we don't \n        // know how many faces contain the vertex, so we call that n, and we need 3 faces to find the three_plane_intersection,\n        // so for this case we need n choose 3. We also only need to find one combination of three faces that are not parallel \n        // with each other, so we need to break the loop early if thats the case as we're done, as computing cross products is\n        // expensive and we want to avoid doing it.\n\n        // An array of the indices of containsVertex (from 0 to containsVertex.length - 1)\n        const array = new Array(containsVertex.length).fill(0).\n          map((v, i) => i);\n\n        // Gives a list of the first elements of the combinations, and we have\n        // length - 2 because slice excludes the element of the end index, since we\n        // need two more elements from the last element of the listoffirstelements\n        // to give us a total of three elements, ie if we let listoffirstelements\n        // run across the whole array we'd have outputs where it would loop around from \n        // the end of the array, giving us repeats. We use the indexes so we can preserve\n        // where it is in relation to the whole list, and not have to call a function like\n        // findIndexOf everytime we have an element. We return to the actual elements at the end\n        // when outputting the result.\n\n        const listOfFirstElements = array.slice(0, (array.length - 2));\n\n        let result = '';\n\n        // Console.log(listOfFirstElements);\n\n        // Use each element of listoffirst elements as the first element of the combination\n        loop1:\n        for (const element of listOfFirstElements) {\n\n          // We need the list of second elements to range from the next element than the current\n          // one of listoffirstelements, to the element before the last, so we can save the last at\n          // the very least for the listofthirdelements to preserve a length of 3 for all combinations\n          const listOfSecondElements = array.slice(element + 1, array.length - 1);\n\n          loop2:\n          // Use each element of listofsecondelements as the second element of the combination\n          for (const el of listOfSecondElements) {\n\n            // We can range the listofthirdelements from the next element from the current element\n            // of listofsecondelements to the end, since we only have three elements in our permutations    \n            const listOfThirdElements = array.slice(el + 1);\n            \n            // If element and el meet some condition, in this case that they are not parallel, \n            // move onto the next one in the loop for listofsecondelements\n            if (norm(cross(containsVertex[element].normal, containsVertex[el].normal)) < epsilon) {\n              continue; \n            }\n\n            // We compute the point based on only having two different normals for all the faces that contain the point given.\n            // This corresponds to having a vertex located on an edge, like the edge of a bench. All of the faces that contain\n            // the point either have one normal, for the top of the bench, or another normal, over the edge of the bench, like\n            // in the below diagram.\n            //\n            //\n            //     ^ (first normal)\n            // ----|-----\n            //          |\n            //          | -> (second normal)\n            //          |\n            //          |\n            //\n            // Using trigonometry and the our knowldege of the angle between the normals, the distances above the planes and the \n            // relations between the vectors (ie that the point we need to find is at the opposite point of a kite) we can calculate\n            // the point just based on the two faces. We leave it to be updated in loop3 if we discover a third face that has a different\n            // normal to the first and the second.\n            //\n\n            const angleBetweenNormals = divide(angleBetween(containsVertex[element], containsVertex[el]), 2);\n\n            const c = Math.sqrt(add(Math.sqrt(height), Math.pow(multiply(height, tan(angleBetweenNormals)), 2)));\n\n            const direction = unit(add(containsVertex[element], containsVertex[el]));\n\n            result = add(vertex, multiply(c, direction));\n\n            loop3:\n            // Iterate through the list of third elements to complete our combination\n            for (const l of listOfThirdElements) {\n\n              // If element and l or el and l meet some condition move onto the next one in the loop for listofthirdelements, else make result equal the triplet and break out of the whole loop\n              if ((norm(cross(containsVertex[element].normal, containsVertex[l].normal)) < epsilon) || (norm(cross(containsVertex[el].normal, containsVertex[l].normal)) < epsilon)) { \n                continue;\n\n              }\n\n              // Else make result equal the triplet and break out of the whole loop\n              else {\n                result = [containsVertex[element], containsVertex[el], containsVertex[l]];\n                break loop1;\n              }\n            }\n          }\n        }\n        // If we have a point surrounded by parallel faces (so the loop has run through and hasn't updated result, so result will be '', which is false)\n        // then we add the normal of the face times the height to the point, so we make the point above directly above it.\n        if (!result) {\n          point = add(vertex, multiply(height, unit(this.normal)));\n        } \n\n        // If we had the case where we have an edge and only two faces to calculate it from, then the point is just the result. We test this by checking the\n        // size of the first element in the array result - if it is the case where we only have two different normals the length of the first element will\n        // be a single number as it will be the x coordinate, if it has made it through to loop three and updated result with the three different normals\n        // it will be a vector of size 3, not just a number.\n        else if (result[0].length == 1) {\n          point = result;\n        }\n\n        // If we have 3 faces that contain the point and are not parallel\n        else {\n\n          // Creates three new planes identical to the planes of the three faces that we have found that are not parallel, and scales them by the distance desired\n          const resultPlane1 = result[0].plane;\n          const resultPlane2 = result[1].plane;\n          const resultPlane3 = result[2].plane;\n\n          resultPlane1.scale(height);\n          resultPlane2.scale(height);\n          resultPlane3.scale(height);\n          point = resultPlane1.pointOfIntersectionWithPlanes(resultPlane2, resultPlane3);\n          \n        }\n        \n\n      }\n      pointsAbove.push(point);\n\n    }\n\n    // Console.log('face', pointsAbove);\n    \n    return pointsAbove;\n\n    \n  }\n  \n  // Calculate the dihedrals for a face\n  get dihedrals() {\n\n    // This array will contain three sub arrays (one for each connected face if it exists, if not it will return false),\n    // With the sub arrays containing two values, the dihedral angle and if the edge is a valley or a ridge. A valley is\n    // Where the two faces bend towards each other, like \\/, and a ridge is where they bend away from each other, like /\\.\n    // This becomes important as when creating the struts one needs to tell the difference in order to keep the strut width\n    // The same, otherwise creating a valley as a ridge will cause the struts to be wider, or even incorrect.\n    // Dihedral must not go below 27 degrees for a 2x4 strut\n\n    const dihedrals = [];\n\n    // Iterates through each adjacent face, if it exists, and updates the dihedral and it's type\n    for (const adjacentFace of this.adjacentFaces) {\n\n      // Extract the adjacent face\n      // const adjacentFace = this.adjacentFaces[i];\n\n      // Checks the face exists, if so proceed\n      if (adjacentFace) {\n\n        // Finds the angle between their normals\n        const angle = acos(divide(dot(this.normal, adjacentFace.normal), multiply(norm(this.normal), norm(adjacentFace.normal))));\n\n        // Finds the dihedral angle (interior angle)\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // // Creates a test point to see if the normal direction is inside or outside the tetrahedron formed by the two faces\n        // // Note: assumes face winding has already been performed.\n        // const testpoint = multiply(multiply(epsilon, 2), adjacentFace.normal);\n\n        // // Finds the four points that make up the tetrahedron\n        // const tetrahedron = this.vertices;\n\n        // // Iterate through each of the points in the adjacent face\n        // for (const point of adjacentFace) {\n\n        //   // Check that the point is not in the face and add it to the tetrahedron\n        //   if (!this.contains(point)) tetrahedron.push(point);\n        // }\n\n        // Create a tetrahedron from the points\n\n\n        // If the testpoint is in the tetrahedron, then it returns the dihedral and 'valley', else it returns the dihedral and 'ridge'\n        // PointInsideTetrahedron(tetrahedron, testpoint) ? dihedrals.push([dihedral, 'valley']) : dihedrals.push([dihedral, 'ridge']);\n\n        // Add the dihedrals\n        dihedrals.push({ angle: dihedral, type: 'ridge' });\n\n      } else {\n\n        // The projected normal of the face, projected onto the xz axis\n        const projectedNormal = [this.normal[0], 0, this.normal[2]];\n\n        // Find the angle between the two planes\n        const angle = acos(divide(dot(projectedNormal, this.normal), multiply(norm(projectedNormal), norm(this.normal))));\n\n        // Finds the dihedral from the angle\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // Add the flat dihedral for the bottom struts\n        dihedrals.push({ angle: dihedral, type: null });\n      }\n    }\n\n    // Return the dihedrals\n    return dihedrals;\n  }\n\n  // Calculate the radials for a face\n  get radials() {\n\n    // Create a list of radial angles\n    const radials = [];\n\n    // Iterate through each of the points\n    for (const i in this.vertices) {\n\n      // Define the set of indexes\n      const [i0, i1, i2] = [Number(i), ((Number(i) + 1) % 3), ((Number(i) + 2) % 3)];\n\n      // Multiply the normals (ab, ac)\n      const normals = multiply(norm(subtract(this.vertices[i1], this.vertices[i0])), norm(subtract(this.vertices[i2], this.vertices[i0])));\n\n      // Calculate the radial angle\n      const radial = acos(divide(dot(subtract(this.vertices[i1], this.vertices[i0]), subtract(this.vertices[i2], this.vertices[i0])), normals));\n    \n      // Add the radial angle to the list\n      radials.push(radial);\n    }\n\n    // Return the radials for the face\n    return radials;\n  }\n\n  // Update the indices in the face\n  update([a, b, c]) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Update the indices\n    this[0] = a;\n    this[1] = b;\n    this[2] = c;\n  }\n\n  // Flip the current face\n  flip() {\n\n    // Switch the order from a, b, c to c, b, a\n    this[0] = this[2];\n    this[2] = this[0];\n\n    // Flip the plane\n    this.plane.flip();\n  }\n\n  // Cast the face to a string\n  toString() {\n    \n    // Return the stringified face\n    return JSON.stringify(this);\n  }\n\n  // Evaluate if two faces are the same\n  equals(face) {\n\n    // Throw an error if face is not a Face\n    validate({ face }, 'Face');\n\n    // Check that the faces equal the same value\n    return (this.toString() === face.toString());\n  }\n\n  // Evaluate if the face contains a vertex\n  contains(vertex) {\n\n    // Throw an error if vertex is not a Vertex\n    // Validate({ vertex, Vertex });\n\n    // Find the vertex within the face\n    const match = this.vertices.find(v => v.toString() == JSON.stringify(vertex));\n\n    // Return true if the vertex is in the face\n    return Boolean(match);\n  }\n}"],"file":"face.js"}