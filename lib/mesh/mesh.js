"use strict";exports.__esModule=true;exports.Mesh=void 0;var _math=require("@oneisland/math");var _point=require("../geometry/point");var _vertices=require("../shape/vertices");var _faces=require("../shape/faces");class Mesh{constructor({vertices,faces,label,winding=true}){this.vertices=[];this.faces=[];this.vertices=new _vertices.Vertices(vertices,this);this.faces=new _faces.Faces(faces,this);if(winding)this.faces.computeNormals();if(winding)this.vertices.computeNormals();if(label)this.label=label}get species(){return"Mesh"}get edges(){const edges={};for(const face of this.faces){for(const edge of face.edges){edge.sort((a,b)=>a-b);const key=`${edge[0]}|${edge[1]}`;edges[key]=edge}}return Object.values(edges)}get center(){const point=(0,_math.divide)(this.vertices.reduce((sum,vertex)=>(0,_math.add)(sum,vertex),[0,0,0]),this.vertices.length);return new _point.Point(point)}get area(){return this.faces.area}get volume(){return(0,_math.divide)(this.faces.reduce((sum,face)=>(0,_math.add)(sum,(0,_math.multiply)((0,_math.dot)(face.a,face.normal),Number(face.area))),0),3)}update({vertices,faces}){this.vertices=[];this.faces=[];this.vertices=new _vertices.Vertices(vertices,this);this.faces=new _faces.Faces(faces,this);this.faces.computeNormals();this.vertices.computeNormals()}dispose(){this.faces=null;this.vertices=null}toString(){return JSON.stringify({vertices:this.vertices,faces:this.faces})}}exports.Mesh=Mesh;
//# sourceMappingURL=mesh.js.map