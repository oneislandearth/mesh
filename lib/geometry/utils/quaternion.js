"use strict";exports.__esModule=true;exports.Quaternion=void 0;var _math=require("@oneisland/math");var _validator=require("@oneisland/validator");const{validate,validateArray}=new _validator.Validator("Quaternion");class Quaternion extends Array{constructor({scalar,vector}){validate({scalar},"Number");validateArray({vector},"Number");super(scalar,...vector)}get species(){return"Quaternion"}static fromVector({vector}){validateArray({vector},"Number");return new Quaternion({scalar:0,vector})}static fromAngleAndDirection({angle,direction}){validate({angle},"Angle");validate({direction},"Direction");const[x,y,z]=direction;return new Quaternion({scalar:(0,_math.cos)((0,_math.divide)(angle.radians,2)),vector:[(0,_math.multiply)((0,_math.sin)((0,_math.divide)(angle.radians,2)),x),(0,_math.multiply)((0,_math.sin)((0,_math.divide)(angle.radians,2)),y),(0,_math.multiply)((0,_math.sin)((0,_math.divide)(angle.radians,2)),z)]})}multiply(quaternion){validate({quaternion},"Quaternion");const[s1,v1]=[this.scalar,this.vector];const[s2,v2]=[quaternion.scalar,quaternion.vector];return new Quaternion({scalar:(0,_math.subtract)((0,_math.multiply)(s1,s2),(0,_math.dot)(v1,v2)),vector:(0,_math.add)((0,_math.add)((0,_math.multiply)(s1,v2),(0,_math.multiply)(s2,v1)),(0,_math.cross)(v1,v2))})}rotate(rotationQuaternion){validate({rotationQuaternion},"Quaternion");const inverseRotationQuaterion=new Quaternion({scalar:rotationQuaternion.scalar,vector:(0,_math.unaryMinus)(rotationQuaternion.vector)});const multipliedQuaternion=rotationQuaternion.multiply(this);return multipliedQuaternion.multiply(inverseRotationQuaterion)}static get[Symbol.species](){return Array}get scalar(){return this[0]}get vector(){return[this[1],this[2],this[3]]}}exports.Quaternion=Quaternion;
//# sourceMappingURL=quaternion.js.map