"use strict";exports.__esModule=true;exports.Line=void 0;var _math=require("@oneisland/math");var _point=require("./point");var _plane=require("./plane");var _direction=require("./utils/direction");var _validator=require("@oneisland/validator");const{validate}=new _validator.Validator("Line");class Line{constructor({point,direction}){validate({point},"Point");validate({direction},"Direction");this.point=point;this.direction=direction}get species(){return"Line"}static fromPoints([a,b]){validate({a,b},"Point");return new Line({point:a,direction:new _direction.Direction((0,_math.subtract)(b,a))})}pointFromDistance(distance){validate({distance},"Number");const point=(0,_math.add)(this.point,(0,_math.multiply)(distance,this.direction));return new _point.Point(point)}lineFromDistance(distance){validate({distance},"Number");return new Line({point:this.pointFromDistance(distance),direction:this.direction})}pointOfIntersectionWithPlane(plane){validate({plane},"Plane");if((0,_math.dot)(plane.normal,this.direction))return null;const distance=(0,_math.divide)((0,_math.subtract)(plane.scalar,(0,_math.dot)(plane.normal,this.point)),(0,_math.dot)(plane.normal,this.direction));return this.pointFromDistance(distance)}pointOfIntersectionWithLine(line){validate({line},"Line");const crossDirection=(0,_math.cross)(line.direction,this.direction);const crossDistance=(0,_math.cross)(line.direction,(0,_math.subtract)(this.point,line.point));if(!(0,_math.norm)(crossDistance)||!(0,_math.norm)(crossDirection))return null;const distance=(0,_math.multiply)((0,_math.divide)((0,_math.norm)(crossDistance),(0,_math.norm)(crossDirection)),this.direction);const front=(0,_math.dot)((0,_math.cross)(line.direction,(0,_math.subtract)(line.direction,line.point)),crossDirection)>0;const intersection=front?(0,_math.add)(this.point,distance):(0,_math.subtract)(this.point,distance);return new _point.Point(intersection)}}exports.Line=Line;