"use strict";exports.__esModule=true;exports.Quaternion=void 0;var _vector=require("../vector");class Quaternion extends Array{constructor({scalar,vector}){if(typeof scalar!="number")throw new TypeError("new Quaternion() expects \"scalar\" to be a Number");if(!(vector instanceof _vector.Vector))throw new TypeError("new Quaternion() expects \"vector\" to be a Vector");super(scalar,...vector)}static fromVertex({vertex}){if(!(vertex instanceof Vertex))throw new TypeError("Quaternion.fromVertex expects \"vertex\" to be a Vertex");return new Quaternion({scalar:0,vector:vertex.toVector()})}static fromPoint({point}){if(!(point instanceof Point))throw new TypeError("Quaternion.fromPoint expects \"point\" to be a Point");return new Quaternion({scalar:0,vector:point.toVector()})}static fromRotation({rotation}){if(!(angle instanceof Angle))throw new TypeError("Quaternion.fromRotation expects \"rotation\" to be a Rotation");const{angle,axis}=rotation;return new Quaternion({scalar:cos(divide(angle,2)),vector:new _vector.Vector([multiply(sin(divide(angle,2)),axis.x),multiply(sin(divide(angle,2)),axis.y),multiply(sin(divide(angle,2)),axis.z)])})}multiply(quaternion){if(!(quaternion instanceof Quaternion))throw new TypeError("Quaternion.multiply expects \"quaternion\" to be a Quaternion");const[s1,v1]=[this.scalar,this.vector];const[s2,v2]=[quaternion.scalar,quaternion.vector];return new Quaternion({scalar:subtract(multiply(s1,s2),dot(v1,v2)),vector:new _vector.Vector(add(add(multiply(s1,v2),multiply(s2,v1)),cross(v1,v2)))})}static get[Symbol.species](){return Array}get scalar(){return this[0]}get vector(){return new _vector.Vector(this[1],this[2],this[3])}}exports.Quaternion=Quaternion;