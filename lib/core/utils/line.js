"use strict";exports.__esModule=true;exports.Line=void 0;var _math=require("../../utils/math");var _edge=require("../../geometry/edge");var _direction=require("direction");var _point=require("point");class Line{constructor({point,direction}){this.point=new _point.Point(point);this.direction=new _direction.Direction(direction)}pointFromDistance(distance){return new _point.Point((0,_math.add)(this.point,(0,_math.multiply)(distance,this.direction)))}lineFromDistance(distance){return new Line({point:this.pointFromDistance(distance),direction:this.direction})}edgeFromDistance(distance){return new _edge.Edge([this.point,this.pointFromDistance(distance)])}intersectionPointWith(line){if(!(line instanceof Line))throw new TypeError("Line.intersectionPointWith expects an Line to be passed");if((0,_math.cross)(line.direction,(0,_math.subtract)(this.point,line.point))||(0,_math.cross)(line.direction,this.direction))return;const distance=(0,_math.multiply)((0,_math.divide)((0,_math.cross)(line.direction,(0,_math.subtract)(this.point,line.point)),(0,_math.cross)(line.direction,this.direction)),this.direction);const front=(0,_math.dot)((0,_math.cross)(line.direction,(0,_math.subtract)(line.direction,line.point)),(0,_math.cross)(line.direction,this.direction))>0;const intersection=front?(0,_math.add)(this.point,distance):(0,_math.subtract)(this.point,distance);return new _point.Point(intersection)}}exports.Line=Line;