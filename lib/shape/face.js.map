{"version":3,"sources":["../../src/shape/face.js"],"names":["validate","Validator","Face","Array","constructor","a","b","c","mesh","species","Symbol","index","Error","Number","faces","findIndex","face","equals","vertices","plane","normal","Direction","scalar","Plane","vertexNormals","edges","Edge","center","Point","area","adjacentFaces","findAdjacentFaceFromEdgeIndex","edgeIndex","i0","i1","i2","faceIndex","edgeCheck","indexOf","otherCheck","pointsAbove","distance","planes","clone","map","i","scale","missingAdjacentIndex","v","vertexIndex","planeFace","planeFaceAB","planeFaceBC","planeFaceCA","pointA","pointOfIntersectionWithPlanes","pointB","pointC","dihedrals","adjacentFace","angle","dihedral","pi","push","type","projectedNormal","radials","normals","radial","update","flip","toString","JSON","stringify","contains","vertex","match","find","Boolean"],"mappings":"yDACA,qCAGA,wCACA,wCAGA,sDAGA,4BAMA,+CAGA,KAAM,CAAEA,QAAF,EAAe,GAAIC,qBAAJ,CAAc,MAAd,CAArB,CAGO,KAAMC,CAAAA,IAAN,QAAmBC,CAAAA,KAAM,CAG9BC,WAAW,CAAC,CAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAD,CAAYC,IAAI,CAAG,IAAnB,CAAyB,CAGlCR,QAAQ,CAAC,CAAEK,CAAF,CAAKC,CAAL,CAAQC,CAAR,CAAD,CAAc,QAAd,CAAR,CAGAP,QAAQ,CAAC,CAAEQ,IAAF,CAAD,CAAW,MAAX,CAAR,CAGA,MAAMH,CAAN,CAASC,CAAT,CAAYC,CAAZ,EAGA,KAAKC,IAAL,CAAYA,IACb,CAGD,GAAIC,CAAAA,OAAJ,EAAc,CAGZ,MAAO,MACR,CAGD,WAAYC,MAAM,CAACD,OAAnB,GAA8B,CAC5B,MAAON,CAAAA,KACR,CAGD,GAAIQ,CAAAA,KAAJ,EAAY,CAGV,GAAI,CAAC,KAAKH,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,4DAAX,CAAN,CAGhB,MAAOC,CAAAA,MAAM,CAAC,KAAKL,IAAL,CAAUM,KAAV,CAAgBC,SAAhB,CAA0BC,IAAI,EAAIA,IAAI,CAACC,MAAL,CAAY,IAAZ,CAAlC,CAAD,CACd,CAGD,GAAIZ,CAAAA,CAAJ,EAAQ,CACN,MAAO,MAAKa,QAAL,CAAc,CAAd,CACR,CAGD,GAAIZ,CAAAA,CAAJ,EAAQ,CACN,MAAO,MAAKY,QAAL,CAAc,CAAd,CACR,CAGD,GAAIX,CAAAA,CAAJ,EAAQ,CACN,MAAO,MAAKW,QAAL,CAAc,CAAd,CACR,CAGD,GAAIA,CAAAA,QAAJ,EAAe,CAGb,GAAI,CAAC,KAAKV,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,+DAAX,CAAN,CAGhB,MAAO,CACL,KAAKJ,IAAL,CAAUU,QAAV,CAAmB,KAAK,CAAL,CAAnB,CADK,CAEL,KAAKV,IAAL,CAAUU,QAAV,CAAmB,KAAK,CAAL,CAAnB,CAFK,CAGL,KAAKV,IAAL,CAAUU,QAAV,CAAmB,KAAK,CAAL,CAAnB,CAHK,CAKR,CAGD,GAAIC,CAAAA,KAAJ,EAAY,CAGV,GAAI,CAAC,KAAKX,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,iEAAX,CAAN,CAGhB,KAAMQ,CAAAA,MAAM,CAAG,GAAIC,qBAAJ,CAAc,gBAAM,mBAAS,KAAKhB,CAAd,CAAiB,KAAKC,CAAtB,CAAN,CAAgC,mBAAS,KAAKC,CAAd,CAAiB,KAAKD,CAAtB,CAAhC,CAAd,CAAf,CAGA,KAAMgB,CAAAA,MAAM,CAAG,cAAIF,MAAJ,CAAY,KAAKf,CAAjB,CAAf,CAGA,MAAO,IAAIkB,aAAJ,CAAU,CAAEH,MAAF,CAAUE,MAAV,CAAV,CACR,CAGD,GAAIF,CAAAA,MAAJ,EAAa,CAGX,GAAI,CAAC,KAAKZ,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,yEAAX,CAAN,CAGhB,MAAO,MAAKO,KAAL,CAAWC,MACnB,CAGD,GAAII,CAAAA,aAAJ,EAAoB,CAGlB,GAAI,CAAC,KAAKhB,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,iFAAX,CACvB,CAGD,GAAIa,CAAAA,KAAJ,EAAY,CAGV,MAAO,CACL,GAAIC,WAAJ,CAAS,CAAC,KAAK,CAAL,CAAD,CAAU,KAAK,CAAL,CAAV,CAAT,CAA6B,KAAKlB,IAAlC,CADK,CAEL,GAAIkB,WAAJ,CAAS,CAAC,KAAK,CAAL,CAAD,CAAU,KAAK,CAAL,CAAV,CAAT,CAA6B,KAAKlB,IAAlC,CAFK,CAGL,GAAIkB,WAAJ,CAAS,CAAC,KAAK,CAAL,CAAD,CAAU,KAAK,CAAL,CAAV,CAAT,CAA6B,KAAKlB,IAAlC,CAHK,CAKR,CAGD,GAAImB,CAAAA,MAAJ,EAAa,CAGX,GAAI,CAAC,KAAKnB,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,kEAAX,CAAN,CAGhB,MAAO,IAAIgB,aAAJ,CAAU,iBAAO,cAAI,KAAKvB,CAAT,CAAY,KAAKC,CAAjB,CAAoB,KAAKC,CAAzB,CAAP,CAAoC,CAApC,CAAV,CACR,CAGD,GAAIsB,CAAAA,IAAJ,EAAW,CAGT,GAAI,CAAC,KAAKrB,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,gEAAX,CAAN,CAGhB,MAAO,mBAAS,iBAAO,eAAK,gBAAM,mBAAS,KAAKP,CAAd,CAAiB,KAAKC,CAAtB,CAAN,CAAgC,mBAAS,KAAKD,CAAd,CAAiB,KAAKE,CAAtB,CAAhC,CAAL,CAAP,CAAwE,CAAxE,CAAT,CACR,CAGD,GAAIuB,CAAAA,aAAJ,EAAoB,CAGlB,GAAI,CAAC,KAAKtB,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,qEAAX,CAAN,CAGhB,MAAO,CAGL,KAAKmB,6BAAL,CAAmC,CAAnC,CAHK,CAML,KAAKA,6BAAL,CAAmC,CAAnC,CANK,CASL,KAAKA,6BAAL,CAAmC,CAAnC,CATK,CAWR,CAGDA,6BAA6B,CAACC,SAAD,CAAY,CAGvC,GAAI,CAAC,KAAKxB,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,uFAAX,CAAN,CAGhB,KAAMqB,CAAAA,EAAE,CAAID,SAAZ,CACA,KAAME,CAAAA,EAAE,CAAI,CAACF,SAAS,CAAG,CAAb,EAAkB,CAA9B,CAGA,KAAMG,CAAAA,EAAE,CAAI,CAACH,SAAS,CAAG,CAAb,EAAkB,CAA9B,CAGA,KAAMI,CAAAA,SAAS,CAAG,KAAK5B,IAAL,CAAUM,KAAV,CAAgBC,SAAhB,CAA0BC,IAAI,EAAI,CAGlD,KAAMqB,CAAAA,SAAS,CAAI,CAACrB,IAAI,CAACsB,OAAL,CAAa,KAAKL,EAAL,CAAb,CAAD,EAA2B,CAACjB,IAAI,CAACsB,OAAL,CAAa,KAAKJ,EAAL,CAAb,CAA/C,CAGA,KAAMK,CAAAA,UAAU,CAAIvB,IAAI,CAACsB,OAAL,CAAa,KAAKH,EAAL,CAAb,GAA0B,CAAC,CAA/C,CAGA,MAAQE,CAAAA,SAAS,EAAIE,UACtB,CAViB,CAAlB,CAaA,MAAQ,CAACH,SAAF,CAAe,KAAK5B,IAAL,CAAUM,KAAV,CAAgBsB,SAAhB,CAAf,CAA4C,IACpD,CAGDI,WAAW,CAACC,QAAD,CAAW,CAGpBzC,QAAQ,CAAC,CAAEyC,QAAF,CAAD,CAAe,QAAf,CAAR,CAGA,KAAMC,CAAAA,MAAM,CAAG,CAAC,KAAKvB,KAAL,CAAWwB,KAAX,EAAD,CAAqB,GAAG,KAAKb,aAAL,CAAmBc,GAAnB,CAAuB5B,IAAI,EAAMA,IAAD,CAASA,IAAI,CAACG,KAAL,CAAWwB,KAAX,EAAT,CAA8B,IAA9D,CAAxB,CAAf,CAGA,IAAK,KAAME,CAAAA,CAAX,GAAgBH,CAAAA,MAAhB,CAAwB,CAGtB,GAAIA,MAAM,CAACG,CAAD,CAAV,CAAeH,MAAM,CAACG,CAAD,CAAN,CAAUC,KAAV,CAAgBL,QAAhB,CAChB,CAGD,KAAMM,CAAAA,oBAAoB,CAAG,KAAKjB,aAAL,CAAmBf,SAAnB,CAA6BiC,CAAC,EAAIA,CAAC,GAAK,IAAxC,CAA7B,CAGA,GAAI,CAACD,oBAAL,CAA2B,CAGzB,KAAME,CAAAA,WAAW,CAAIF,oBAAoB,EAAI,CAAzB,CAA8B,CAA9B,CAAmCA,oBAAoB,EAAI,CAAzB,CAA8B,CAA9B,CAAkCA,oBAAxF,CAGAL,MAAM,CAAC,EAAIK,oBAAL,CAAN,CAAmC,GAAIxB,aAAJ,CAAU,CAG3CH,MAAM,CAAE,GAAIC,qBAAJ,CAAc,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAd,CAHmC,CAM3CC,MAAM,CAAE,cAAI,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAJ,CAAe,KAAKJ,QAAL,CAAc+B,WAAd,CAAf,CANmC,CAAV,CAQpC,CAGD,KAAM,CAACC,SAAD,CAAYC,WAAZ,CAAyBC,WAAzB,CAAsCC,WAAtC,EAAqDX,MAA3D,CAaA,KAAMY,CAAAA,MAAM,CAAGJ,SAAS,CAACK,6BAAV,CAAwCJ,WAAxC,CAAqDE,WAArD,CAAf,CACA,KAAMG,CAAAA,MAAM,CAAGN,SAAS,CAACK,6BAAV,CAAwCJ,WAAxC,CAAqDC,WAArD,CAAf,CACA,KAAMK,CAAAA,MAAM,CAAGP,SAAS,CAACK,6BAAV,CAAwCH,WAAxC,CAAqDC,WAArD,CAAf,CAGA,MAAO,CAACC,MAAD,CAASE,MAAT,CAAiBC,MAAjB,CACR,CAGD,GAAIC,CAAAA,SAAJ,EAAgB,CASd,KAAMA,CAAAA,SAAS,CAAG,EAAlB,CAGA,IAAK,KAAMC,CAAAA,YAAX,GAA2B,MAAK7B,aAAhC,CAA+C,CAM7C,GAAI6B,YAAJ,CAAkB,CAGhB,KAAMC,CAAAA,KAAK,CAAG,eAAK,iBAAO,cAAI,KAAKxC,MAAT,CAAiBuC,YAAY,CAACvC,MAA9B,CAAP,CAA8C,mBAAS,eAAK,KAAKA,MAAV,CAAT,CAA4B,eAAKuC,YAAY,CAACvC,MAAlB,CAA5B,CAA9C,CAAL,CAAd,CAGA,KAAMyC,CAAAA,QAAQ,CAAG,iBAAO,mBAASC,QAAT,CAAaF,KAAb,CAAP,CAA4B,CAA5B,CAAjB,CAuBAF,SAAS,CAACK,IAAV,CAAe,CAAEH,KAAK,CAAEC,QAAT,CAAmBG,IAAI,CAAE,OAAzB,CAAf,CAED,CA/BD,IA+BO,CAGL,KAAMC,CAAAA,eAAe,CAAG,CAAC,KAAK7C,MAAL,CAAY,CAAZ,CAAD,CAAiB,CAAjB,CAAoB,KAAKA,MAAL,CAAY,CAAZ,CAApB,CAAxB,CAGA,KAAMwC,CAAAA,KAAK,CAAG,eAAK,iBAAO,cAAIK,eAAJ,CAAqB,KAAK7C,MAA1B,CAAP,CAA0C,mBAAS,eAAK6C,eAAL,CAAT,CAAgC,eAAK,KAAK7C,MAAV,CAAhC,CAA1C,CAAL,CAAd,CAGA,KAAMyC,CAAAA,QAAQ,CAAG,iBAAO,mBAASC,QAAT,CAAaF,KAAb,CAAP,CAA4B,CAA5B,CAAjB,CAGAF,SAAS,CAACK,IAAV,CAAe,CAAEH,KAAK,CAAEC,QAAT,CAAmBG,IAAI,CAAE,IAAzB,CAAf,CACD,CACF,CAGD,MAAON,CAAAA,SACR,CAGD,GAAIQ,CAAAA,OAAJ,EAAc,CAGZ,KAAMA,CAAAA,OAAO,CAAG,EAAhB,CAGA,IAAK,KAAMrB,CAAAA,CAAX,GAAgB,MAAK3B,QAArB,CAA+B,CAG7B,KAAM,CAACe,EAAD,CAAKC,EAAL,CAASC,EAAT,EAAe,CAACtB,MAAM,CAACgC,CAAD,CAAP,CAAa,CAAChC,MAAM,CAACgC,CAAD,CAAN,CAAY,CAAb,EAAkB,CAA/B,CAAoC,CAAChC,MAAM,CAACgC,CAAD,CAAN,CAAY,CAAb,EAAkB,CAAtD,CAArB,CAGA,KAAMsB,CAAAA,OAAO,CAAG,mBAAS,eAAK,mBAAS,KAAKjD,QAAL,CAAcgB,EAAd,CAAT,CAA4B,KAAKhB,QAAL,CAAce,EAAd,CAA5B,CAAL,CAAT,CAA+D,eAAK,mBAAS,KAAKf,QAAL,CAAciB,EAAd,CAAT,CAA4B,KAAKjB,QAAL,CAAce,EAAd,CAA5B,CAAL,CAA/D,CAAhB,CAGA,KAAMmC,CAAAA,MAAM,CAAG,eAAK,iBAAO,cAAI,mBAAS,KAAKlD,QAAL,CAAcgB,EAAd,CAAT,CAA4B,KAAKhB,QAAL,CAAce,EAAd,CAA5B,CAAJ,CAAoD,mBAAS,KAAKf,QAAL,CAAciB,EAAd,CAAT,CAA4B,KAAKjB,QAAL,CAAce,EAAd,CAA5B,CAApD,CAAP,CAA4GkC,OAA5G,CAAL,CAAf,CAGAD,OAAO,CAACH,IAAR,CAAaK,MAAb,CACD,CAGD,MAAOF,CAAAA,OACR,CAGDG,MAAM,CAAC,CAAChE,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAD,CAAY,CAGhBP,QAAQ,CAAC,CAAEK,CAAF,CAAKC,CAAL,CAAQC,CAAR,CAAD,CAAc,QAAd,CAAR,CAGA,KAAK,CAAL,EAAUF,CAAV,CACA,KAAK,CAAL,EAAUC,CAAV,CACA,KAAK,CAAL,EAAUC,CACX,CAGD+D,IAAI,EAAG,CAGL,KAAK,CAAL,EAAU,KAAK,CAAL,CAAV,CACA,KAAK,CAAL,EAAU,KAAK,CAAL,CAAV,CAGA,KAAKnD,KAAL,CAAWmD,IAAX,EACD,CAGDC,QAAQ,EAAG,CAGT,MAAOC,CAAAA,IAAI,CAACC,SAAL,CAAe,IAAf,CACR,CAGDxD,MAAM,CAACD,IAAD,CAAO,CAGXhB,QAAQ,CAAC,CAAEgB,IAAF,CAAD,CAAW,MAAX,CAAR,CAGA,MAAQ,MAAKuD,QAAL,KAAoBvD,IAAI,CAACuD,QAAL,EAC7B,CAGDG,QAAQ,CAACC,MAAD,CAAS,CAMf,KAAMC,CAAAA,KAAK,CAAG,KAAK1D,QAAL,CAAc2D,IAAd,CAAmB7B,CAAC,EAAIA,CAAC,CAACuB,QAAF,IAAgBC,IAAI,CAACC,SAAL,CAAeE,MAAf,CAAxC,CAAd,CAGA,MAAOG,CAAAA,OAAO,CAACF,KAAD,CACf,CApY6B,C","sourcesContent":["// Import the required math functions\nimport { divide, add, subtract, norm, cross, dot, toMeters, epsilon, pi, acos, multiply, unit } from '@oneisland/math';\n\n// Import the required geometry modules\nimport { Plane } from 'geometry/plane';\nimport { Point } from 'geometry/point';\n\n// Import the required geometry utilities\nimport { Direction } from 'geometry/utils/direction';\n\n// Import the required shape modules\nimport { Edge } from 'shape/edge';\n\n// Imoprt point in polygon function\n// Import { pointInsideTetrahedron } from 'point_inside_tetrahedron.js';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Face');\n\n// Define a class face which is an array of three vertices plus extra properties\nexport class Face extends Array {\n\n  // Bind the indices to the mesh and any mesh\n  constructor([a, b, c], mesh = null) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Throw an error if the mesh in not a Mesh\n    validate({ mesh }, 'Mesh');\n\n    // Call the super function to bind our indices\n    super(a, b, c);\n\n    // Bind the reference to the current mesh if there is one\n    this.mesh = mesh;\n  }\n\n  // Define the species\n  get species() {\n  \n    // Define the species as 'Face'\n    return 'Face';\n  }\n\n  // Define the species to be an array\n  static get [Symbol.species]() {\n    return Array; \n  }\n\n  // Find the index of the face in the mesh faces\n  get index() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the index - the face is not bound to a Mesh`);\n\n    // Return the index of the face in the faces\n    return Number(this.mesh.faces.findIndex(face => face.equals(this)));\n  }\n\n  // Compute the value of vertex a\n  get a() {\n    return this.vertices[0];\n  }\n\n  // Compute the value of vertex b\n  get b() {\n    return this.vertices[1];\n  }\n\n  // Compute the value of vertex c\n  get c() {\n    return this.vertices[2];\n  }\n\n  // Find the vertices for the face based on the indices\n  get vertices() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);\n\n    // Return the vertices based on the indices\n    return [\n      this.mesh.vertices[this[0]], \n      this.mesh.vertices[this[1]], \n      this.mesh.vertices[this[2]]\n    ];  \n  }\n\n  // Find the Plane from a face\n  get plane() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);\n\n    // Calculate the normal of the Plane\n    const normal = new Direction(cross(subtract(this.a, this.b), subtract(this.c, this.b)));\n\n    // Calculate the scalar of the Plane\n    const scalar = dot(normal, this.a);\n\n    // Return the Plane from the Face\n    return new Plane({ normal, scalar });\n  }\n\n  // Compute the normal of the face\n  get normal() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);\n\n    // Return the normal for the face\n    return this.plane.normal;\n  }\n  \n  // Compute the vertex normals\n  get vertexNormals() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertex normals of the face - the face is not bound to a Mesh`);\n  }\n\n  // Find the edges from the face\n  get edges() {\n\n    // Return the edges in the face (ab, bc, ca)\n    return [\n      new Edge([this[0], this[1]], this.mesh), \n      new Edge([this[1], this[2]], this.mesh), \n      new Edge([this[2], this[0]], this.mesh)\n    ];\n  }\n\n  // Compute the center of a face\n  get center() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);\n\n    // Calculate the center of the face\n    return new Point(divide(add(this.a, this.b, this.c), 3));\n  }\n\n  // Compute the area of a mesh\n  get area() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);\n  \n    // Calculate the area of a triangle = norm(cross product(a-b, a-c))\n    return toMeters(divide(norm(cross(subtract(this.a, this.b), subtract(this.a, this.c))), 2));\n  }\n\n  // Find the adjacent faces to the face\n  get adjacentFaces() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);\n\n    // Return the list of adjacent faces\n    return [\n      \n      // Find face at edge ab/ba\n      this.findAdjacentFaceFromEdgeIndex(0), \n      \n      // Find face at edge bc/cb\n      this.findAdjacentFaceFromEdgeIndex(1),\n\n      // Find face at edge ca/ac\n      this.findAdjacentFaceFromEdgeIndex(2)\n    ];\n  }\n\n  // Find an adjacent face from an edge index (0: ab, 1: bc, 2: ca)\n  findAdjacentFaceFromEdgeIndex(edgeIndex) {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent face fom the edge index - the face is not bound to a Mesh`);\n\n    // Determine the vertex which make up the edge\n    const i0 = (edgeIndex);\n    const i1 = ((edgeIndex + 1) % 3);\n\n    // Determine the vertex which is not part of the edge\n    const i2 = ((edgeIndex + 2) % 3);\n\n    // Find the index of the adjacent face\n    const faceIndex = this.mesh.faces.findIndex(face => {\n      \n      // Check that the face contains i0 and i1 (the edge)\n      const edgeCheck = (~face.indexOf(this[i0]) && ~face.indexOf(this[i1]));\n\n      // Check that the face doesn't contain the current index (same face)\n      const otherCheck = (face.indexOf(this[i2]) == -1);\n\n      // Return true if the face is an adjacent face\n      return (edgeCheck && otherCheck);\n    });\n\n    // Return null if there is no face / face index, or return the face\n    return (~faceIndex) ? this.mesh.faces[faceIndex] : null;\n  }\n\n  // Find the face a specific distance above\n  pointsAbove(distance) {\n\n    // Throw an error if distance is not a Number\n    validate({ distance }, 'Number');\n\n    // Create a list of planes (face, faceAB, faceBC, faceCA)\n    const planes = [this.plane.clone(), ...this.adjacentFaces.map(face => ((face) ? face.plane.clone() : null))];\n\n    // Scale each of the planes by the distance\n    for (const i in planes) {\n\n      // Check if there is a plane and scale it by the distance\n      if (planes[i]) planes[i].scale(distance);\n    }\n\n    // Find the index of the non-existing adjacent face if there is one\n    const missingAdjacentIndex = this.adjacentFaces.findIndex(v => v === null);\n\n    // Check if there is a missing face\n    if (~missingAdjacentIndex) {\n\n      // Define which vertex from the edge to use based on which adjacent face is missing (0, 1, 2 == 2, 1, 0)\n      const vertexIndex = (missingAdjacentIndex == 0) ? 2 : (missingAdjacentIndex == 2) ? 0 : missingAdjacentIndex;\n\n      // Creates a new plane that is parallel to the xz plane and contains one point of the edge\n      planes[1 + missingAdjacentIndex] = new Plane({\n        \n        // Calculate the normal\n        normal: new Direction([0, 1, 0]), \n        \n        // Calculate the scalar based on the edge\n        scalar: dot([0, 1, 0], this.vertices[vertexIndex])\n      });\n    }\n\n    // Extract each of the planes\n    const [planeFace, planeFaceAB, planeFaceBC, planeFaceCA] = planes;\n\n    // Finds the three lines of intersection between the original face and the three planes\n    // const lineAB = planeFace.lineOfIntersectionWith(planeFaceAB);\n    // const lineBC = planeFace.lineOfIntersectionWith(planeFaceBC);\n    // const lineCA = planeFace.lineOfIntersectionWith(planeFaceCA);\n\n    // Finds the three points of intersection between the three lines\n    // const pointA = lineAB.pointOfIntersectionWithLine(lineCA);\n    // const pointB = lineBC.pointOfIntersectionWithLine(lineAB);\n    // const pointC = lineCA.pointOfIntersectionWithLine(lineBC);\n\n    // Find the point of intersection between three faces\n    const pointA = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceCA);\n    const pointB = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceBC);\n    const pointC = planeFace.pointOfIntersectionWithPlanes(planeFaceBC, planeFaceCA);\n\n    // Return three points above\n    return [pointA, pointB, pointC];\n  }\n  \n  // Calculate the dihedrals for a face\n  get dihedrals() {\n\n    // This array will contain three sub arrays (one for each connected face if it exists, if not it will return false),\n    // With the sub arrays containing two values, the dihedral angle and if the edge is a valley or a ridge. A valley is\n    // Where the two faces bend towards each other, like \\/, and a ridge is where they bend away from each other, like /\\.\n    // This becomes important as when creating the struts one needs to tell the difference in order to keep the strut width\n    // The same, otherwise creating a valley as a ridge will cause the struts to be wider, or even incorrect.\n    // Dihedral must not go below 27 degrees for a 2x4 strut\n\n    const dihedrals = [];\n\n    // Iterates through each adjacent face, if it exists, and updates the dihedral and it's type\n    for (const adjacentFace of this.adjacentFaces) {\n\n      // Extract the adjacent face\n      // const adjacentFace = this.adjacentFaces[i];\n\n      // Checks the face exists, if so proceed\n      if (adjacentFace) {\n\n        // Finds the angle between their normals\n        const angle = acos(divide(dot(this.normal, adjacentFace.normal), multiply(norm(this.normal), norm(adjacentFace.normal))));\n\n        // Finds the dihedral angle (interior angle)\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // // Creates a test point to see if the normal direction is inside or outside the tetrahedron formed by the two faces\n        // // Note: assumes face winding has already been performed.\n        // const testpoint = multiply(multiply(epsilon, 2), adjacentFace.normal);\n\n        // // Finds the four points that make up the tetrahedron\n        // const tetrahedron = this.vertices;\n\n        // // Iterate through each of the points in the adjacent face\n        // for (const point of adjacentFace) {\n\n        //   // Check that the point is not in the face and add it to the tetrahedron\n        //   if (!this.contains(point)) tetrahedron.push(point);\n        // }\n\n        // Create a tetrahedron from the points\n\n\n        // If the testpoint is in the tetrahedron, then it returns the dihedral and 'valley', else it returns the dihedral and 'ridge'\n        // PointInsideTetrahedron(tetrahedron, testpoint) ? dihedrals.push([dihedral, 'valley']) : dihedrals.push([dihedral, 'ridge']);\n\n        // Add the dihedrals\n        dihedrals.push({ angle: dihedral, type: 'ridge' });\n\n      } else {\n\n        // The projected normal of the face, projected onto the xz axis\n        const projectedNormal = [this.normal[0], 0, this.normal[2]];\n\n        // Find the angle between the two planes\n        const angle = acos(divide(dot(projectedNormal, this.normal), multiply(norm(projectedNormal), norm(this.normal))));\n\n        // Finds the dihedral from the angle\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // Add the flat dihedral for the bottom struts\n        dihedrals.push({ angle: dihedral, type: null });\n      }\n    }\n\n    // Return the dihedrals\n    return dihedrals;\n  }\n\n  // Calculate the radials for a face\n  get radials() {\n\n    // Create a list of radial angles\n    const radials = [];\n\n    // Iterate through each of the points\n    for (const i in this.vertices) {\n\n      // Define the set of indexes\n      const [i0, i1, i2] = [Number(i), ((Number(i) + 1) % 3), ((Number(i) + 2) % 3)];\n\n      // Multiply the normals (ab, ac)\n      const normals = multiply(norm(subtract(this.vertices[i1], this.vertices[i0])), norm(subtract(this.vertices[i2], this.vertices[i0])));\n\n      // Calculate the radial angle\n      const radial = acos(divide(dot(subtract(this.vertices[i1], this.vertices[i0]), subtract(this.vertices[i2], this.vertices[i0])), normals));\n    \n      // Add the radial angle to the list\n      radials.push(radial);\n    }\n\n    // Return the radials for the face\n    return radials;\n  }\n\n  // Update the indices in the face\n  update([a, b, c]) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Update the indices\n    this[0] = a;\n    this[1] = b;\n    this[2] = c;\n  }\n\n  // Flip the current face\n  flip() {\n\n    // Switch the order from a, b, c to c, b, a\n    this[0] = this[2];\n    this[2] = this[0];\n\n    // Flip the plane\n    this.plane.flip();\n  }\n\n  // Cast the face to a string\n  toString() {\n    \n    // Return the stringified face\n    return JSON.stringify(this);\n  }\n\n  // Evaluate if two faces are the same\n  equals(face) {\n\n    // Throw an error if face is not a Face\n    validate({ face }, 'Face');\n\n    // Check that the faces equal the same value\n    return (this.toString() === face.toString());\n  }\n\n  // Evaluate if the face contains a vertex\n  contains(vertex) {\n\n    // Throw an error if vertex is not a Vertex\n    // Validate({ vertex, Vertex });\n\n    // Find the vertex within the face\n    const match = this.vertices.find(v => v.toString() == JSON.stringify(vertex));\n\n    // Return true if the vertex is in the face\n    return Boolean(match);\n  }\n}"],"file":"face.js"}