{"version":3,"sources":["../../src/shape/edge.js"],"names":["validate","Validator","Edge","Array","constructor","a","b","mesh","species","Symbol","vertices","Error","length","direction","Direction","lerp","fraction","Point","toLine","Line","fromPoints","toPoint","toString","JSON","stringify","equals","edge","contains","vertex","match","filter","v","Boolean"],"mappings":"yDACA,qCAGA,sCACA,wCAGA,sDAGA,gCAGA,kCAGA,+CAGA,KAAM,CAAEA,QAAF,EAAe,GAAIC,qBAAJ,CAAc,MAAd,CAArB,CAGO,KAAMC,CAAAA,IAAN,QAAmBC,CAAAA,KAAM,CAG9BC,WAAW,CAAC,CAACC,CAAD,CAAIC,CAAJ,CAAD,CAASC,IAAI,CAAG,IAAhB,CAAsB,CAG/BP,QAAQ,CAAC,CAAEK,CAAF,CAAKC,CAAL,CAAD,CAAW,QAAX,CAAR,CAGAN,QAAQ,CAAC,CAAEO,IAAF,CAAD,CAAW,MAAX,CAAR,CAGA,MAAMF,CAAN,CAASC,CAAT,EAGA,KAAKC,IAAL,CAAYA,IACb,CAGD,GAAIC,CAAAA,OAAJ,EAAc,CAGZ,MAAO,MACR,CAGD,WAAYC,MAAM,CAACD,OAAnB,GAA8B,CAC5B,MAAOL,CAAAA,KACR,CAGD,GAAIE,CAAAA,CAAJ,EAAQ,CACN,MAAO,MAAKK,QAAL,CAAc,CAAd,CACR,CAGD,GAAIJ,CAAAA,CAAJ,EAAQ,CACN,MAAO,MAAKI,QAAL,CAAc,CAAd,CACR,CAGD,GAAIA,CAAAA,QAAJ,EAAe,CAGb,GAAI,CAAC,KAAKH,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,+DAAX,CAAN,CAGhB,MAAO,CACL,KAAKJ,IAAL,CAAUG,QAAV,CAAmB,KAAK,CAAL,CAAnB,CADK,CAEL,KAAKH,IAAL,CAAUG,QAAV,CAAmB,KAAK,CAAL,CAAnB,CAFK,CAIR,CAGD,GAAIE,CAAAA,MAAJ,EAAa,CAGX,GAAI,CAAC,KAAKL,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,yEAAX,CAAN,CAGhB,MAAO,mBAAS,mBAAS,KAAKN,CAAd,CAAiB,KAAKC,CAAtB,CAAT,CACR,CAGD,GAAIO,CAAAA,SAAJ,EAAgB,CAGd,GAAI,CAAC,KAAKN,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,4EAAX,CAAN,CAGhB,MAAO,IAAIG,qBAAJ,CAAc,mBAAS,KAAKR,CAAd,CAAiB,KAAKD,CAAtB,CAAd,CACR,CAGDU,IAAI,CAACC,QAAD,CAAW,CAGb,GAAI,CAAC,KAAKT,IAAV,CAAgB,KAAM,IAAII,CAAAA,KAAJ,CAAW,mFAAX,CAAN,CAGhB,MAAO,IAAIM,aAAJ,CAAU,mBAASD,QAAT,CAAmB,mBAAS,KAAKV,CAAd,CAAiB,KAAKD,CAAtB,CAAnB,CAAV,CACR,CAGDa,MAAM,EAAG,CAGP,MAAOC,YAAKC,UAAL,CAAgB,CAAC,KAAKf,CAAL,CAAOgB,OAAP,EAAD,CAAmB,KAAKf,CAAL,CAAOe,OAAP,EAAnB,CAAhB,CACR,CAGDC,QAAQ,EAAG,CAGT,MAAOC,CAAAA,IAAI,CAACC,SAAL,CAAe,IAAf,CACR,CAGDC,MAAM,CAACC,IAAD,CAAO,CAGX1B,QAAQ,CAAC,CAAE0B,IAAF,CAAD,CAAW,MAAX,CAAR,CAMA,MAAQ,MAAKJ,QAAL,KAAoBI,IAAI,CAACJ,QAAL,EAC7B,CAGDK,QAAQ,CAACC,MAAD,CAAS,CAMf,KAAMC,CAAAA,KAAK,CAAG,KAAKnB,QAAL,CAAcoB,MAAd,CAAqBC,CAAC,EAAIA,CAAC,CAACT,QAAF,IAAgBM,MAAM,CAACN,QAAP,EAA1C,CAAd,CAGA,MAAOU,CAAAA,OAAO,CAACH,KAAD,CACf,CAzH6B,C","sourcesContent":["// Import the required math functions\nimport { distance, subtract, multiply, toMeters } from '@oneisland/math';\n\n// Import the required geometry modules\nimport { Line } from 'geometry/line';\nimport { Point } from 'geometry/point';\n\n// Import the required geometry utilities\nimport { Direction } from 'geometry/utils/direction';\n\n// Import the required shape modules\nimport { Vertex } from 'shape/vertex';\n\n// Import the core mesh module\nimport { Mesh } from 'mesh/mesh';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Edge');\n\n// Define a class edge which is an array of three vertices plus extra properties\nexport class Edge extends Array {\n\n  // Bind the indices of an edge with reference to the mesh\n  constructor([a, b], mesh = null) {\n\n    // Throw an error if a or b is not a Number\n    validate({ a, b }, 'Number');\n\n    // Throw an error if the mesh in not a Mesh\n    validate({ mesh }, 'Mesh');\n\n    // Call the super function to bind the indices\n    super(a, b);\n\n    // Bind the reference to the current mesh if there is one\n    this.mesh = mesh;\n  }\n\n  // Define the species\n  get species() {\n  \n    // Define the species as 'Edge'\n    return 'Edge';\n  }\n\n  // Define the species to be an array\n  static get [Symbol.species]() {\n    return Array; \n  }\n\n  // Compute the value of vertex a\n  get a() {\n    return this.vertices[0];\n  }\n\n  // Compute the value of vertex b\n  get b() {\n    return this.vertices[1];\n  }\n\n  // Find the vertices for the vertex based on the indices\n  get vertices() {\n\n    // Check if the edge is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertices - the edge is not bound to a Mesh`);\n\n    // Return the vertices based on the indices\n    return [\n      this.mesh.vertices[this[0]], \n      this.mesh.vertices[this[1]]\n    ];  \n  }\n\n  // Comput the length of an edge\n  get length() {\n\n    // Check if the edge is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the length of the edge - the edge is not bound to a Mesh`);\n\n    // Calculate the length of the edge\n    return toMeters(distance(this.a, this.b));\n  }\n\n  // Get the direction of an edge\n  get direction() {\n\n    // Check if the edge is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the direction of the edge - the edge is not bound to a Mesh`);\n\n    // Calculate the direction of the edge\n    return new Direction(subtract(this.b, this.a));\n  }\n\n  // Find a Point along the Edge\n  lerp(fraction) {\n\n    // Check if the edge is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute linear interpolation of the edge - the edge is not bound to a Mesh`);\n  \n    // Return the Point alone the Edge\n    return new Point(multiply(fraction, subtract(this.b, this.a)));\n  }\n\n  // Cast an Edge to a Line\n  toLine() {\n\n    // Return the new Line from the Edge\n    return Line.fromPoints([this.a.toPoint(), this.b.toPoint()]);\n  }\n\n  // Cast the edge to a string\n  toString() {\n    \n    // Return the stringified edge\n    return JSON.stringify(this);\n  }\n\n  // Evaluate if two edges are the same\n  equals(edge) {\n\n    // Throw an error if face is not a Face\n    validate({ edge }, 'Edge');\n\n    // Clone and reverse the edge\n    // const reversed = new Edge(edge.slice().reverse(), this.mesh);\n\n    // Check that the edges equal the same value\n    return (this.toString() === edge.toString());\n  }\n\n  // Evaluate if the edge contains a vertex\n  contains(vertex) {\n\n    // Throw an error if vertex is not a Vertex\n    // validate({ vertex, Vertex });\n\n    // Find the vertex within the edge\n    const match = this.vertices.filter(v => v.toString() == vertex.toString());\n\n    // Return true if the vertex is in the edge\n    return Boolean(match);\n  }\n}"],"file":"edge.js"}