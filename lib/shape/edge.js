"use strict";exports.__esModule=true;exports.Edge=void 0;var _math=require("@oneisland/math");var _line=require("../geometry/line");var _point=require("../geometry/point");var _direction=require("../geometry/utils/direction");var _vertex=require("./vertex");var _mesh=require("../mesh/mesh");var _validator=require("@oneisland/validator");const{validate}=new _validator.Validator("Edge");class Edge extends Array{constructor([a,b],mesh=null){validate({a,b},"Number");validate({mesh},"Mesh");super(a,b);this.mesh=mesh}get species(){return"Edge"}static get[Symbol.species](){return Array}get a(){return this.vertices[0]}get b(){return this.vertices[1]}get vertices(){if(!this.mesh)throw new Error(`Cannot compute the vertices - the edge is not bound to a Mesh`);return[this.mesh.vertices[this[0]],this.mesh.vertices[this[1]]]}get length(){if(!this.mesh)throw new Error(`Cannot compute the length of the edge - the edge is not bound to a Mesh`);return(0,_math.toMeters)((0,_math.distance)(this.a,this.b))}get direction(){if(!this.mesh)throw new Error(`Cannot compute the direction of the edge - the edge is not bound to a Mesh`);return new _direction.Direction((0,_math.subtract)(this.b,this.a))}lerp(fraction){if(!this.mesh)throw new Error(`Cannot compute linear interpolation of the edge - the edge is not bound to a Mesh`);return new _point.Point((0,_math.multiply)(fraction,(0,_math.subtract)(this.b,this.a)))}toLine(){return _line.Line.fromPoints([this.a.toPoint(),this.b.toPoint()])}toString(){return JSON.stringify(this)}equals(edge){validate({edge},"Edge");return this.toString()===edge.toString()}contains(vertex){const match=this.vertices.filter(v=>v.toString()==vertex.toString());return Boolean(match)}}exports.Edge=Edge;