{"version":3,"sources":["../../src/geometry/polygon.js"],"names":["validate","validateAll","Validator","Polygon","Array","constructor","points","p","length","species","plane","Plane","fromPolygon","normal","area","signedArea","sum","i","pi","pn","clockwise","flip","containsPoint","point","inside","projectionIndex","findIndex","value","pointProjected","projectToPlane","filter","v","index","polygonProjected","map","polygon","x","y","j","xi","yi","xj","yj","intersection","Boolean"],"mappings":"4DACA,qCAGA,8BACA,8BAGA,+CAGA,KAAM,CAAEA,QAAF,CAAYC,WAAZ,EAA4B,GAAIC,qBAAJ,CAAc,SAAd,CAAlC,CAGO,KAAMC,CAAAA,OAAN,QAAsBC,CAAAA,KAAM,CAGjCC,WAAW,CAACC,MAAD,CAAS,CAGlBN,QAAQ,CAAC,CAAEM,MAAF,CAAD,CAAcC,CAAD,EAAOA,CAAC,CAACC,MAAF,CAAW,CAA/B,CAAmC,2CAAnC,CAAR,CAGAP,WAAW,CAAC,CAAEK,MAAF,CAAD,CAAa,CAAC,OAAD,CAAU,QAAV,CAAb,CAAmC,4CAAnC,CAAX,CAGA,MAAM,GAAGA,MAAT,CACD,CAGD,GAAIG,CAAAA,OAAJ,EAAc,CAGZ,MAAO,SACR,CAGD,GAAIC,CAAAA,KAAJ,EAAY,CAGV,MAAOC,cAAMC,WAAN,CAAkB,IAAlB,CACR,CAGD,GAAIC,CAAAA,MAAJ,EAAa,CAGX,MAAO,MAAKH,KAAL,CAAWG,MACnB,CAGD,GAAIC,CAAAA,IAAJ,EAAW,CAGT,MAAO,cAAI,KAAKC,UAAT,CACR,CAGDA,UAAU,CAACF,MAAD,CAAS,CAGjB,GAAIG,CAAAA,GAAG,CAAG,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAV,CAGA,IAAK,KAAMC,CAAAA,CAAX,GAAgB,KAAhB,CAAsB,CAGpB,KAAMC,CAAAA,EAAE,CAAG,KAAKD,CAAL,CAAX,CAGA,KAAME,CAAAA,EAAE,CAAG,KAAM,CAACF,CAAC,CAAG,CAAL,EAAU,KAAKT,MAArB,CAAX,CAGAQ,GAAG,CAAG,cAAIA,GAAJ,CAAS,gBAAME,EAAN,CAAUC,EAAV,CAAT,CACP,CAGD,MAAO,iBAAO,cAAKN,MAAD,CAAWA,MAAX,CAAoB,KAAKH,KAAL,CAAWG,MAAnC,CAA2CG,GAA3C,CAAP,CAAwD,CAAxD,CACR,CAGD,GAAII,CAAAA,SAAJ,EAAgB,CAGd,GAAI,KAAKL,UAAL,IAAqB,CAAzB,CAA4B,MAAO,KAAP,CAG5B,MAAO,MACR,CAiBDM,IAAI,EAAG,CACL,KAAKX,KAAL,CAAWW,IAAX,EACD,CAGDC,aAAa,CAACC,KAAD,CAAQ,CAGnB,GAAI,CAAC,KAAKb,KAAL,CAAWY,aAAX,CAAyBC,KAAzB,CAAL,CAAsC,MAAO,MAAP,CAGtC,GAAIC,CAAAA,MAAM,CAAG,CAAb,CAGA,KAAMC,CAAAA,eAAe,CAAG,KAAKZ,MAAL,CAAYa,SAAZ,CAAsBC,KAAK,EAAKA,KAAK,EAAI,cAAI,GAAG,KAAKd,MAAZ,CAAzC,CAAxB,CAGA,KAAMe,CAAAA,cAAc,CAAGL,KAAK,CAACM,cAAN,CAAqB,KAAKnB,KAA1B,EAAiCoB,MAAjC,CAAwC,CAACC,CAAD,CAAIC,KAAJ,GAAeA,KAAK,EAAIP,eAAhE,CAAvB,CAGA,KAAMQ,CAAAA,gBAAgB,CAAG,CAAC,GAAG,IAAJ,EAAUC,GAAV,CAAcC,OAAO,EAAIA,OAAO,CAACL,MAAR,CAAe,CAACC,CAAD,CAAIC,KAAJ,GAAeA,KAAK,EAAIP,eAAvC,CAAzB,CAAzB,CAGA,KAAM,CAACW,CAAD,CAAIC,CAAJ,EAAST,cAAf,CAGA,GAAIU,CAAAA,CAAC,CAAIL,gBAAgB,CAACzB,MAAjB,CAA0B,CAAnC,CAGA,IAAK,KAAMS,CAAAA,CAAX,GAAgBgB,CAAAA,gBAAhB,CAAkC,CAGhC,KAAM,CAACM,EAAD,CAAKC,EAAL,EAAWP,gBAAgB,CAAChB,CAAD,CAAjC,CAGA,KAAM,CAACwB,EAAD,CAAKC,EAAL,EAAWT,gBAAgB,CAACK,CAAD,CAAjC,CAGA,GAAME,EAAE,EAAIH,CAAP,EAAcK,EAAE,CAAGL,CAApB,EAA6BK,EAAE,EAAIL,CAAP,EAAcG,EAAE,CAAGH,CAAnD,CAAwD,CAGtD,KAAMM,CAAAA,YAAY,CAAG,cAAI,iBAAO,mBAAS,mBAASF,EAAT,CAAaF,EAAb,CAAT,CAA2B,mBAASF,CAAT,CAAYG,EAAZ,CAA3B,CAAP,CAAoD,mBAASE,EAAT,CAAaF,EAAb,CAApD,CAAJ,CAA2ED,EAA3E,CAArB,CAGA,GAAIH,CAAC,CAAGO,YAAR,CAAsBnB,MAAM,CAAG,CAACA,MACjC,CAGDc,CAAC,CAAGrB,CACL,CAGD,MAAO2B,CAAAA,OAAO,CAACpB,MAAD,CACf,CAhJgC,C","sourcesContent":["// Import the required math functions\nimport { cross, dot, add, abs, divide, subtract, max, multiply } from '@oneisland/math';\n\n// Import the required geometry modules\nimport { Plane } from 'geometry/plane';\nimport { Point} from 'geometry/point';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate, validateAll } = new Validator('Polygon');\n\n// Create a polygon which represents an arbitary shaped shape in 3D space\nexport class Polygon extends Array {\n\n  // Create a new polygon from a number of points\n  constructor(points) {\n\n    // Check the polygon contains three or more points\n    validate({ points }, (p) => p.length > 2, `\"points\" to contain at least three points`);\n\n    // Check that the points are all points\n    validateAll({ points }, ['Point', 'Vertex'], `\"points\" to be an array of Point instances`);\n\n    // Bind the the points to the polygon\n    super(...points);\n  }\n\n  // Define the species\n  get species() {\n\n    // Define the species as 'Polygon'\n    return 'Polygon';\n  }\n\n  // Compute the plane of the polygon\n  get plane() {\n\n    // Return the Plane from the polygon\n    return Plane.fromPolygon(this);\n  }\n\n  // Compute the normal of the polygon\n  get normal() {\n\n    // Return the normal of the polygon\n    return this.plane.normal;\n  }\n\n  // Compute the area of a polygon\n  get area() {\n\n    // Return the area of the polygon\n    return abs(this.signedArea);\n  }\n\n  // Computed the signed area\n  signedArea(normal) {\n\n    // Define the sum of the polygon\n    let sum = [0, 0, 0];\n  \n    // Iterate through each of the points in the polygon\n    for (const i in this) {\n  \n      // Extract the current point\n      const pi = this[i];\n  \n      // Extract the next point\n      const pn = this[((i + 1) % this.length)];\n        \n      // Add to the sum\n      sum = add(sum, cross(pi, pn));\n    }\n  \n    // Return the signed area\n    return divide(dot((normal) ? normal : this.plane.normal, sum), 2);\n  }\n\n  // Compute whether the winding direction is clockwise\n  get clockwise() {\n\n    // Return true as the the signed area is greater than equal to zero\n    if (this.signedArea() >= 0) return true;\n\n    // Return false as the order is counter-clockwise\n    return false;\n  }\n\n  // // Compute whether the polygon is coplanar\n  // get coplanar() {\n\n  //   // Iterate through each of the points in the polygon\n  //   for (const point of this) {\n\n  //     // Return false if the point is not on the plane\n  //     if (!this.plane.containsPoint(point)) return false;\n  //   }\n\n  //   // Return true as the polygon is coplanar\n  //   return true;\n  // }\n\n  // Flip\n  flip() {\n    this.plane.flip();\n  }\n\n  // Check if a point is contained inside the polygon using the ray-casting method\n  containsPoint(point) {\n\n    // Return false if the point is not on the plane\n    if (!this.plane.containsPoint(point)) return false;\n\n    // Define a flag for counting the even / odd crosses\n    let inside = 0;\n    \n    // Find the largest index (x, y, z) from the polygon normal\n    const projectionIndex = this.normal.findIndex(value => (value == max(...this.normal)));\n\n    // Project the point to the polygon plane and remove the vertex component from the point which equals the projection index\n    const pointProjected = point.projectToPlane(this.plane).filter((v, index) => (index != projectionIndex));\n\n    // Remove the vertex component from each of the polygon vertices which equal the projection index\n    const polygonProjected = [...this].map(polygon => polygon.filter((v, index) => (index != projectionIndex)));\n\n    // Extract the x and y values from the projected point\n    const [x, y] = pointProjected;\n   \n    // Let j be the index before the first index i (the last index as i is 0)\n    let j = (polygonProjected.length - 1);\n\n    // Iterate through each of the projected points in the polygon\n    for (const i in polygonProjected) {\n\n      // Extract the x and y values of index i\n      const [xi, yi] = polygonProjected[i];      \n      \n      // Extract the x and y values of index j\n      const [xj, yj] = polygonProjected[j];\n\n      // Check whether the lines crosses the horizontal line at y in either direction, and ignore edges which it doesn't intersect with\n      if (((yi <= y) && (yj > y)) || ((yj <= y) && (yi > y))) {\n\n        // Find the intersection where the point crosses the edge of the polgygon\n        const intersection = add(divide(multiply(subtract(xj, xi), subtract(y, yi)), subtract(yj, yi)), xi);\n\n        // Check if the intersection crosses to the left of the point, and if so toggle the inside / outside check\n        if (x < intersection) inside = !inside;\n      }\n\n      // Set j to the value of i\n      j = i;\n    }\n\n    // If the number of crosses is odd then the point is inside\n    return Boolean(inside);\n  }\n}"],"file":"polygon.js"}