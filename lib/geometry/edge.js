"use strict";exports.__esModule=true;exports.Edge=void 0;var _math=require("../utils/math");var _number=require("../utils/number");var _direction=require("../core/utils/direction");var _vector=require("src/core/utils/vector");class Edge extends Array{constructor([a,b]){super(a,b)}static get[Symbol.species](){return Array}get mapped(){return Array.isArray(this.a)&&Array.isArray(this.b)}get a(){return this[0]}set a(a){this[0]=a}get b(){return this[1]}set b(b){this[1]=b}get length(){if(!this.mapped)throw new Error(`Cannot compute the edge length - the edge is not mapped to vertices`);return new _number.MetricNumber((0,_math.distance)(this.a,this.b))}get direction(){if(!this.mapped)throw new Error(`Cannot compute the edge direction - the edge is not mapped to vertices`);return new _direction.Direction((0,_math.unit)((0,_math.subtract)(this.b,this.a)))}lerp(fraction){if(!this.mapped)throw new Error(`Cannot compute the vector using lerp - the edge is not mapped to vertices`);return new _vector.Vertex((0,_math.multiply)(fraction,(0,_math.subtract)(this.b,this.a)))}intersectionWith(edge){if(!(edge instanceof Edge))throw new TypeError("Edge.intersectionWith expects an Edge to be passed");const distance=(0,_math.multiply)((0,_math.divide)((0,_math.cross)(edge.direction,(0,_math.subtract)(this.a,edge.a)),(0,_math.cross)(edge.direction,this.direction)),this.direction);const front=(0,_math.dot)((0,_math.cross)(edge.direction,(0,_math.subtract)(edge.direction,edge.a)),(0,_math.cross)(edge.direction,this.direction))>0;const intersection=front?(0,_math.add)(this.a,distance):(0,_math.subtract)(this.a,distance);return new _vector.Vertex(intersection)}mapVertices([a,b]){[this.a,this.b]=[a,b];return this}}exports.Edge=Edge;