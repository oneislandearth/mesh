"use strict";exports.__esModule=true;exports.Plane=void 0;var _math=require("@oneisland/math");var _line=require("./line");var _point=require("./point");var _polygon=require("./polygon");var _direction=require("./utils/direction");var _validator=require("@oneisland/validator");const{validate}=new _validator.Validator("Plane");class Plane{constructor({normal,scalar}){validate({normal},"Direction");validate({scalar},"Number");this.normal=normal;this.scalar=scalar}get species(){return"Plane"}static fromPolygon(polygon){validate({polygon},"Polygon");const normal=new _direction.Direction((0,_math.cross)((0,_math.subtract)(polygon[1],polygon[0]),(0,_math.subtract)(polygon[2],polygon[0])));const scalar=(0,_math.dot)(normal,polygon[0]);return new Plane({normal,scalar})}clone(){return new Plane({normal:this.normal,scalar:this.scalar})}flip(){this.normal=(0,_math.multiply)(this.normal,-1);this.scalar=(0,_math.multiply)(this.scalar,-1)}scale(distance){validate({distance},"Number");this.scalar=(0,_math.add)(this.scalar,distance)}containsPoint(point){return(0,_math.subtract)(this.scalar,(0,_math.dot)(this.normal,point))<=_math.epsilon}lineOfIntersectionWith(plane){validate({plane},"Plane");const[n1,s1]=[this.normal,this.scalar];const[n2,s2]=[plane.normal,plane.scalar];const direction=(0,_math.cross)(n1,n2);if((0,_math.isZeroes)(direction))return null;const c1=(0,_math.divide)((0,_math.subtract)(s1,(0,_math.multiply)(s2,(0,_math.dot)(n1,n2))),(0,_math.subtract)(1,(0,_math.multiply)((0,_math.dot)(n1,n2),(0,_math.dot)(n1,n2))));const c2=(0,_math.divide)((0,_math.subtract)(s2,(0,_math.multiply)(s1,(0,_math.dot)(n1,n2))),(0,_math.subtract)(1,(0,_math.multiply)((0,_math.dot)(n1,n2),(0,_math.dot)(n1,n2))));const point=(0,_math.add)((0,_math.multiply)(c1,n1),(0,_math.multiply)(c2,n2));return new _line.Line({point:new _point.Point(point),direction:new _direction.Direction(direction)})}pointOfIntersectionWithPlanes(plane1,plane2){validate({plane1,plane2},"Plane");const[n1,s1]=[this.normal,this.scalar];const[n2,s2]=[plane1.normal,plane1.scalar];const[n3,s3]=[plane2.normal,plane2.scalar];const determinant=(0,_math.det)((0,_math.transpose)([n1,n2,n3]));if((0,_math.isZeroes)(determinant))return null;const intersection=(0,_math.divide)((0,_math.add)((0,_math.multiply)(s1,(0,_math.cross)(n2,n3)),(0,_math.add)((0,_math.multiply)(s2,(0,_math.cross)(n3,n1)),(0,_math.multiply)(s3,(0,_math.cross)(n1,n2)))),determinant);return new _point.Point(intersection)}equals(plane){validate({plane},"Plane");return this.toString()==plane.toString()}toString(){return JSON.stringify([...this.normal,this.scalar])}}exports.Plane=Plane;