{"version":3,"sources":["../../src/mesh/mesh.js"],"names":["Mesh","constructor","vertices","faces","label","winding","Vertices","Faces","computeNormals","species","edges","face","edge","sort","a","b","key","Object","values","center","point","reduce","sum","vertex","length","Point","area","volume","normal","Number","update","dispose","toString","JSON","stringify"],"mappings":"yDACA,qCAGA,wCAGA,2CACA,qCAGO,KAAMA,CAAAA,IAAK,CAEhBC,WAAW,CAAC,CAAEC,QAAF,CAAYC,KAAZ,CAAmBC,KAAnB,CAA0BC,OAAO,CAAG,IAApC,CAAD,CAA6C,CAGtD,KAAKH,QAAL,CAAgB,EAAhB,CACA,KAAKC,KAAL,CAAa,EAAb,CAGA,KAAKD,QAAL,CAAgB,GAAII,mBAAJ,CAAaJ,QAAb,CAAuB,IAAvB,CAAhB,CAGA,KAAKC,KAAL,CAAa,GAAII,aAAJ,CAAUJ,KAAV,CAAiB,IAAjB,CAAb,CAGA,GAAIE,OAAJ,CAAa,KAAKF,KAAL,CAAWK,cAAX,GAGb,GAAIH,OAAJ,CAAa,KAAKH,QAAL,CAAcM,cAAd,GAGb,GAAIJ,KAAJ,CAAW,KAAKA,KAAL,CAAaA,KACzB,CAGD,GAAIK,CAAAA,OAAJ,EAAc,CAGZ,MAAO,MACR,CAGD,GAAIC,CAAAA,KAAJ,EAAY,CAGV,KAAMA,CAAAA,KAAK,CAAG,EAAd,CAGA,IAAK,KAAMC,CAAAA,IAAX,GAAmB,MAAKR,KAAxB,CAA+B,CAG7B,IAAK,KAAMS,CAAAA,IAAX,GAAmBD,CAAAA,IAAI,CAACD,KAAxB,CAA+B,CAG7BE,IAAI,CAACC,IAAL,CAAU,CAACC,CAAD,CAAIC,CAAJ,GAAUD,CAAC,CAAGC,CAAxB,EAGA,KAAMC,CAAAA,GAAG,CAAI,GAAEJ,IAAI,CAAC,CAAD,CAAI,IAAGA,IAAI,CAAC,CAAD,CAAI,EAAlC,CAGAF,KAAK,CAACM,GAAD,CAAL,CAAaJ,IACd,CACF,CAGD,MAAOK,CAAAA,MAAM,CAACC,MAAP,CAAcR,KAAd,CACR,CAGD,GAAIS,CAAAA,MAAJ,EAAa,CAGX,KAAMC,CAAAA,KAAK,CAAG,iBAAO,KAAKlB,QAAL,CAAcmB,MAAd,CAAqB,CAACC,GAAD,CAAMC,MAAN,GAAiB,cAAID,GAAJ,CAASC,MAAT,CAAtC,CAAwD,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAxD,CAAP,CAA2E,KAAKrB,QAAL,CAAcsB,MAAzF,CAAd,CAGA,MAAO,IAAIC,aAAJ,CAAUL,KAAV,CACR,CAGD,GAAIM,CAAAA,IAAJ,EAAW,CAGT,MAAO,MAAKvB,KAAL,CAAWuB,IACnB,CAGD,GAAIC,CAAAA,MAAJ,EAAa,CAGX,MAAO,iBAAO,KAAKxB,KAAL,CAAWkB,MAAX,CAAkB,CAACC,GAAD,CAAMX,IAAN,GAAe,cAAIW,GAAJ,CAAS,mBAAS,cAAIX,IAAI,CAACG,CAAT,CAAYH,IAAI,CAACiB,MAAjB,CAAT,CAAmCC,MAAM,CAAClB,IAAI,CAACe,IAAN,CAAzC,CAAT,CAAjC,CAAkG,CAAlG,CAAP,CAA6G,CAA7G,CACR,CAGDI,MAAM,CAAC,CAAE5B,QAAF,CAAYC,KAAZ,CAAD,CAAsB,CAG1B,KAAKD,QAAL,CAAgB,EAAhB,CACA,KAAKC,KAAL,CAAa,EAAb,CAGA,KAAKD,QAAL,CAAgB,GAAII,mBAAJ,CAAaJ,QAAb,CAAuB,IAAvB,CAAhB,CAGA,KAAKC,KAAL,CAAa,GAAII,aAAJ,CAAUJ,KAAV,CAAiB,IAAjB,CAAb,CAGA,KAAKA,KAAL,CAAWK,cAAX,GAGA,KAAKN,QAAL,CAAcM,cAAd,EACD,CAGDuB,OAAO,EAAG,CAGR,KAAK5B,KAAL,CAAa,IAAb,CACA,KAAKD,QAAL,CAAgB,IAGjB,CAOD8B,QAAQ,EAAG,CAGT,MAAOC,CAAAA,IAAI,CAACC,SAAL,CAAe,CACpBhC,QAAQ,CAAE,KAAKA,QADK,CAEpBC,KAAK,CAAE,KAAKA,KAFQ,CAAf,CAIR,CA5He,C","sourcesContent":["// Import the required math functions\nimport { add, divide, multiply, dot } from '@oneisland/math';\n\n// Import the required geometry modules\nimport { Point } from 'geometry/point';\n\n// Import the required shape modules\nimport { Vertices } from 'shape/vertices';\nimport { Faces } from 'shape/faces';\n\n// Create a new mesh from vertices and faces (indices)\nexport class Mesh {\n\n  constructor({ vertices, faces, label, winding = true }) {\n\n    // Bind an empty array of vertices and faces\n    this.vertices = [];\n    this.faces = [];\n\n    // Bind the vertices to the mesh\n    this.vertices = new Vertices(vertices, this);\n\n    // Bind the faces to the mesh\n    this.faces = new Faces(faces, this);\n    \n    // Compute the correct face normals if winding is true\n    if (winding) this.faces.computeNormals();\n\n    // Compute the correcct vertex normals\n    if (winding) this.vertices.computeNormals();\n\n    // Add the label to the mesh if there is one\n    if (label) this.label = label;\n  }\n\n  // Define the species\n  get species() {\n\n    // Define the species as 'Mesh'\n    return 'Mesh';\n  }\n\n  // Compute the edges of the face\n  get edges() {\n\n    // Define the object of edges\n    const edges = {};\n\n    // Iterate through each of the faces\n    for (const face of this.faces) {\n\n      // Iterate through each of the faces\n      for (const edge of face.edges) {\n\n        // Order the edge by indice order\n        edge.sort((a, b) => a - b);\n\n        // Create a key from the edge\n        const key = `${edge[0]}|${edge[1]}`;\n\n        // Add the edge based on a key\n        edges[key] = edge;\n      }\n    }\n\n    // Return the list of edges\n    return Object.values(edges);\n  }\n\n  // Calculate the center point of the mesh\n  get center() {\n\n    // Calculate the center of all vertices\n    const point = divide(this.vertices.reduce((sum, vertex) => add(sum, vertex), [0, 0, 0]), this.vertices.length);\n\n    // Return the center point\n    return new Point(point);\n  }\n\n  // Calculate the area of the mesh\n  get area() {\n\n    // Return the area of the mesh\n    return this.faces.area;\n  }\n\n  // Calculate the volume of the mesh\n  get volume() {\n\n    // Return the volume of the mesh\n    return divide(this.faces.reduce((sum, face) => add(sum, multiply(dot(face.a, face.normal), Number(face.area))), 0), 3);\n  }\n\n  // Update a mesh with new vertices and faces\n  update({ vertices, faces }) {\n\n    // Clear the vertices and faces\n    this.vertices = [];\n    this.faces = [];\n\n    // Bind the vertices to the mesh\n    this.vertices = new Vertices(vertices, this);\n\n    // Bind the faces to the mesh\n    this.faces = new Faces(faces, this);\n\n    // Compute the correct face normals\n    this.faces.computeNormals();\n\n    // Compute the correcct vertex normals\n    this.vertices.computeNormals();\n  }\n\n  // Dispose the mesh\n  dispose() {\n\n    // Dispose each of the faces and vertices\n    this.faces = null;\n    this.vertices = null;\n\n    // Delete this;\n  }\n\n  // Subtract(mesh) {\n\n  // }\n\n  // Cast the mesh to a string\n  toString() {\n\n    // Return the stringified data on the mesh\n    return JSON.stringify({\n      vertices: this.vertices,\n      faces: this.faces\n    });\n  }\n}"],"file":"mesh.js"}