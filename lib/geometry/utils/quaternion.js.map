{"version":3,"sources":["../../../src/geometry/utils/quaternion.js"],"names":["validate","validateArray","Validator","Quaternion","Array","constructor","scalar","vector","species","fromVector","fromAngleAndDirection","angle","direction","x","y","z","radians","multiply","quaternion","s1","v1","s2","v2","rotate","rotationQuaternion","inverseRotationQuaterion","multipliedQuaternion","Symbol"],"mappings":"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","sourcesContent":["// Import the required math functions\nimport { cos, divide, sin, multiply, subtract, add, dot, cross, unaryMinus } from '@oneisland/math';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate, validateArray } = new Validator('Quaternion');\n\n// Calculate a Quaternion from a scalar and vector\nexport class Quaternion extends Array {\n\n  // Create a new Quaternion from the scalar and vector\n  constructor({ scalar, vector }) {\n\n    // Throw an error if the scalar is not a Number\n    validate({ scalar }, 'Number');\n\n    // Throw an error if the values in vector are not Number\n    validateArray({ vector }, 'Number');\n\n    // Call the super function to bind our coodinates to the array\n    super(scalar, ...vector);\n  }\n\n  // Define the species\n  get species() {\n  \n    // Define the species as 'Quaternion'\n    return 'Quaternion';\n  }\n\n  // Create a new Quaternion from a Vector\n  static fromVector({ vector }) {\n\n    // Throw an error if the values in vector are not Number\n    validateArray({ vector }, 'Number');\n\n    // Return the new Quaternion\n    return new Quaternion({ scalar: 0, vector });\n  }\n\n  // Create a new Quaternion from a rotaton (angle and axis)\n  static fromAngleAndDirection({ angle, direction }) {\n\n    // Throw an error if the angle is not an Angle\n    validate({ angle }, 'Angle');\n\n    // Throw an error if the direction is not a Direction\n    validate({ direction }, 'Direction');\n\n    // Extract the x, y and z values from the direction\n    const [x, y, z] = direction;\n\n    // Return the Quaternion\n    return new Quaternion({ \n\n      // Calculate the scalar\n      scalar: cos(divide(angle.radians, 2)), \n\n      // Calculate the vector\n      vector: [\n\n        // Calculate the x value\n        multiply(sin(divide(angle.radians, 2)), x),\n\n        // Calculate the y value\n        multiply(sin(divide(angle.radians, 2)), y),\n\n        // Calculate the z value\n        multiply(sin(divide(angle.radians, 2)), z)\n      ]\n    });\n\n  }\n\n  // Multiply two Quaternions using the Hamilton Product\n  multiply(quaternion) {\n\n    // This function is non-commutative as cross(v1, v2) != cross(v2, v1)\n    // The current (this) quaternion must be the the rotation quaterion\n    // The passed (quaternion) quaternion must be the point quaterion\n\n    // Throw an error if the quaternion is not a Quaternion\n    validate({ quaternion }, 'Quaternion');\n\n    // Extract the scalar and vector values from the quaternions\n    const [s1, v1] = [this.scalar, this.vector];\n    const [s2, v2] = [quaternion.scalar, quaternion.vector];\n\n    // Return the resulting quaternion from the multiplication\n    return new Quaternion({\n      \n      // Calculate the scalar\n      scalar: subtract(multiply(s1, s2), dot(v1, v2)),\n      \n      // Calculate the vector\n      vector: add(add(multiply(s1, v2), multiply(s2, v1)), cross(v1, v2))\n    });\n  }\n\n  // Rotate a point quaternion by the rotation quaternion\n  rotate(rotationQuaternion) {\n\n    // Throw an error if the rotationQuaternion is not a Quaternion\n    validate({ rotationQuaternion }, 'Quaternion');\n    \n    // Create the inverse of the rotation quaternion\n    const inverseRotationQuaterion = new Quaternion({ scalar: rotationQuaternion.scalar, vector: unaryMinus(rotationQuaternion.vector) });\n\n    // Perform the first multiplication with the rotation quaternion\n    const multipliedQuaternion = rotationQuaternion.multiply(this);\n\n    // Return the rotated quaternion\n    return multipliedQuaternion.multiply(inverseRotationQuaterion);\n  }\n\n  // Define the species to be an array\n  static get [Symbol.species]() {\n    return Array; \n  }\n\n  // Determine the current scalar of the Quaternion\n  get scalar() {\n\n    // Return the scalar part of the quaternion\n    return this[0];\n  }\n\n  // Determine the current vector of the Quaternion\n  get vector() {\n\n    // Return the vector part of the quaternion\n    return [this[1], this[2], this[3]];\n  }\n}"],"file":"quaternion.js"}