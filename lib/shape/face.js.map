<<<<<<< HEAD
{"version":3,"sources":["../../src/shape/face.js"],"names":["validate","Validator","Face","Array","constructor","a","b","c","mesh","species","Symbol","index","Error","Number","faces","findIndex","face","equals","vertices","plane","normal","Direction","scalar","Plane","vertexNormals","edges","Edge","center","Point","area","adjacentFaces","findAdjacentFaceFromEdgeIndex","edgeIndex","i0","i1","i2","faceIndex","edgeCheck","indexOf","otherCheck","pointsAbove","height","vertex","console","log","point","missingAdjacentIndex","v","vertexIndex","planes","edgeNow","edgeBefore","length","faceNow","faceBefore","epsilon","newPlane1","newPlane2","newPlane3","scale","pointOfIntersectionWithPlanes","containsVertex","fac","contains","push","array","fill","map","i","listOfFirstElements","slice","result","loop1","element","listOfSecondElements","loop2","el","listOfThirdElements","angleBetweenNormals","Math","sqrt","pow","direction","loop3","l","resultPlane1","resultPlane2","resultPlane3","dihedrals","adjacentFace","angle","dihedral","pi","type","projectedNormal","radials","normals","radial","update","flip","toString","JSON","stringify","match","find","Boolean"],"mappings":"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","sourcesContent":["// Import the required math functions\nimport { divide, add, subtract, norm, cross, dot, toMeters, epsilon, pi, acos, multiply, unit, tan, angleBetween } from '@oneisland/math';\n\n// Import the range function\n// import { range } from 'utils/range_array.js';\n\n// Import the required geometry modules\nimport { Plane } from 'geometry/plane';\nimport { Point } from 'geometry/point';\n\n// Import the required geometry utilities\nimport { Direction } from 'geometry/utils/direction';\n\n// Import the required shape modules\nimport { Edge } from 'shape/edge';\n\n// Imoprt point in polygon function\n// Import { pointInsideTetrahedron } from 'point_inside_tetrahedron.js';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Face');\n\n// Define a class face which is an array of three vertices plus extra properties\nexport class Face extends Array {\n\n  // Bind the indices to the mesh and any mesh\n  constructor([a, b, c], mesh = null) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Throw an error if the mesh in not a Mesh\n    validate({ mesh }, 'Mesh');\n\n    // Call the super function to bind our indices\n    super(a, b, c);\n\n    // Bind the reference to the current mesh if there is one\n    this.mesh = mesh;\n  }\n\n  // Define the species\n  get species() {\n  \n    // Define the species as 'Face'\n    return 'Face';\n  }\n\n  // Define the species to be an array\n  static get [Symbol.species]() {\n    return Array; \n  }\n\n  // Find the index of the face in the mesh faces\n  get index() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the index - the face is not bound to a Mesh`);\n\n    // Return the index of the face in the faces\n    return Number(this.mesh.faces.findIndex(face => face.equals(this)));\n  }\n\n  // Compute the value of vertex a\n  get a() {\n    return this.vertices[0];\n  }\n\n  // Compute the value of vertex b\n  get b() {\n    return this.vertices[1];\n  }\n\n  // Compute the value of vertex c\n  get c() {\n    return this.vertices[2];\n  }\n\n  // Find the vertices for the face based on the indices\n  get vertices() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);\n\n    // Return the vertices based on the indices\n    return [this.mesh.vertices[this[0]], this.mesh.vertices[this[1]], this.mesh.vertices[this[2]]];  \n  }\n\n  // Find the Plane from a face\n  get plane() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);\n\n    // Calculate the normal of the Plane\n    const normal = new Direction(cross(subtract(this.a, this.b), subtract(this.c, this.b)));\n\n    // Calculate the scalar of the Plane\n    const scalar = dot(normal, this.a);\n\n    // Return the Plane from the Face\n    return new Plane({ normal, scalar });\n  }\n\n  // Compute the normal of the face\n  get normal() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);\n\n    // Return the normal for the face\n    return this.plane.normal;\n  }\n  \n  // Compute the vertex normals\n  get vertexNormals() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertex normals of the face - the face is not bound to a Mesh`);\n  }\n\n  // Find the edges from the face\n  get edges() {\n\n    // Return the edges in the face (ab, bc, ca)\n    return [new Edge([this[0], this[1]], this.mesh), new Edge([this[1], this[2]], this.mesh), new Edge([this[2], this[0]], this.mesh)];\n  }\n\n  // Compute the center of a face\n  get center() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);\n\n    // Calculate the center of the face\n    return new Point(divide(add(this.a, this.b, this.c), 3));\n  }\n\n  // Compute the area of a mesh\n  get area() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);\n  \n    // Calculate the area of a triangle = norm(cross product(a-b, a-c))\n    return toMeters(divide(norm(cross(subtract(this.a, this.b), subtract(this.a, this.c))), 2));\n  }\n\n  // Find the adjacent faces to the face\n  get adjacentFaces() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);\n\n    // Return the list of adjacent faces\n    return [\n      \n      // Find face at edge ab/ba\n      this.findAdjacentFaceFromEdgeIndex(0), \n      \n      // Find face at edge bc/cb\n      this.findAdjacentFaceFromEdgeIndex(1),\n\n      // Find face at edge ca/ac\n      this.findAdjacentFaceFromEdgeIndex(2)];\n  }\n\n  // Find an adjacent face from an edge index (0: ab, 1: bc, 2: ca)\n  findAdjacentFaceFromEdgeIndex(edgeIndex) {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent face fom the edge index - the face is not bound to a Mesh`);\n\n    // Determine the vertex which make up the edge\n    const i0 = (edgeIndex);\n    const i1 = ((edgeIndex + 1) % 3);\n\n    // Determine the vertex which is not part of the edge\n    const i2 = ((edgeIndex + 2) % 3);\n\n    // Find the index of the adjacent face\n    const faceIndex = this.mesh.faces.findIndex(face => {\n      \n      // Check that the face contains i0 and i1 (the edge)\n      const edgeCheck = (~face.indexOf(this[i0]) && ~face.indexOf(this[i1]));\n\n      // Check that the face doesn't contain the current index (same face)\n      const otherCheck = (face.indexOf(this[i2]) == -1);\n\n      // Return true if the face is an adjacent face\n      return (edgeCheck && otherCheck);\n    });\n\n    // Return null if there is no face / face index, or return the face\n    return (~faceIndex) ? this.mesh.faces[faceIndex] : null;\n  }\n\n  // // Find the face a specific distance above\n  // pointsAbove(distance) {\n\n  //   // Throw an error if distance is not a Number\n  //   validate({ distance }, 'Number');\n\n  //   // Create a list of planes (face, faceAB, faceBC, faceCA)\n  //   const planes = [this.plane.clone(), ...this.adjacentFaces.map(face => ((face) ? face.plane.clone() : null))];\n\n  //   // Scale each of the planes by the distance\n  //   for (const i in planes) {\n\n  //     // Check if there is a plane and scale it by the distance\n  //     if (planes[i]) planes[i].scale(distance);\n  //   }\n\n  //   // Find the index of the non-existing adjacent face if there is one\n  //   const missingAdjacentIndex = this.adjacentFaces.findIndex(v => v === null);\n\n  //   // Check if there is a missing face\n  //   if (~missingAdjacentIndex) {\n\n  //     // Define which vertex from the edge to use based on which adjacent face is missing (0, 1, 2 == 2, 1, 0)\n  //     const vertexIndex = (missingAdjacentIndex == 0) ? 2 : (missingAdjacentIndex == 2) ? 0 : missingAdjacentIndex;\n\n  //     // Creates a new plane that is parallel to the xz plane and contains one point of the edge\n  //     planes[1 + missingAdjacentIndex] = new Plane({\n        \n  //       // Calculate the normal\n  //       normal: new Direction([0, 1, 0]), \n        \n  //       // Calculate the scalar based on the edge\n  //       scalar: dot([0, 1, 0], this.vertices[vertexIndex])\n  //     });\n  //   }\n\n  //   // Extract each of the planes\n  //   const [planeFace, planeFaceAB, planeFaceBC, planeFaceCA] = planes;\n\n  //   // Finds the three lines of intersection between the original face and the three planes\n  //   // const lineAB = planeFace.lineOfIntersectionWith(planeFaceAB);\n  //   // const lineBC = planeFace.lineOfIntersectionWith(planeFaceBC);\n  //   // const lineCA = planeFace.lineOfIntersectionWith(planeFaceCA);\n\n  //   // Finds the three points of intersection between the three lines\n  //   // const pointA = lineAB.pointOfIntersectionWithLine(lineCA);\n  //   // const pointB = lineBC.pointOfIntersectionWithLine(lineAB);\n  //   // const pointC = lineCA.pointOfIntersectionWithLine(lineBC);\n\n  //   // Find the point of intersection between three faces\n  //   const pointA = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceCA);\n  //   const pointB = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceBC);\n  //   const pointC = planeFace.pointOfIntersectionWithPlanes(planeFaceBC, planeFaceCA);\n\n  //   // Return three points above\n  //   return [pointA, pointB, pointC];\n  // }\n\n  // Updated face above method, deals with coplanar faces\n\n  // Takes in a face and outputs the points above it, whether the faces surrounding it are coplanar or not\n  pointsAbove(height) {\n    // Define the array that will contain the points above the face\n    const pointsAbove = [];\n\n    // Iterate through each vertex in the face\n    for (const vertex of this.vertices) {\n\n      console.log(this.vertices);\n\n      // Define the a variable that is the point that will be returned\n      let point = [];\n\n      // Find the index of the current vertex\n      const index = this.vertices.indexOf(vertex);\n\n      // I took the code for edges without an adjacent face from the old pointsAboveFace method\n\n      // Find the index of the non-existing adjacent face if there is one\n      const missingAdjacentIndex = this.adjacentFaces.findIndex(v => v === null);\n\n      // Check if there is a missing face\n      if (missingAdjacentIndex !== -1) {\n\n        // Define which vertex from the edge to use based on which adjacent face is missing (0, 1, 2 == 2, 1, 0)\n        const vertexIndex = (missingAdjacentIndex == 0) ? 2 : (missingAdjacentIndex == 2) ? 0 : missingAdjacentIndex;\n\n        // Creates a new plane that is parallel to the xz plane and contains one point of the edge\n        this.planes[1 + missingAdjacentIndex] = new Plane({\n          \n          // Calculate the normal\n          normal: new Direction([0, 1, 0]), \n          \n          // Calculate the scalar based on the edge\n          scalar: dot([0, 1, 0], this.vertices[vertexIndex])\n        });\n      }\n\n      // Finds one edge that contains the vertex \n      const edgeNow = this.edges[index];\n\n      // Finds the other edge that contains the vertex (can be used for a polygon of any number of vertices, providing one edge of the polygon has at most one adjacent face)\n      // Finds the edge before the edge defined above\n      const edgeBefore = this.edges[((index + (this.vertices.length - 1)) % this.vertices.length)];\n\n      // Finds the faces that contain edgeNow and edgeBefore\n\n      const faceNow = this.findAdjacentFaceFromEdgeIndex(index);\n\n      const faceBefore = this.findAdjacentFaceFromEdgeIndex(((index + (this.vertices.length - 1)) % this.vertices.length));\n\n      // Checks if the three faces (face, faceNow, faceBefore) are not parallel, if that is the case compute the normals as per usual\n      if (((cross(faceNow.normal, faceBefore.normal) > epsilon) && ((cross(this.normal, faceBefore.normal) > epsilon) && ((cross(faceNow.normal, this.normal) > epsilon))))) {\n\n        // Creates three new planes identical to the planes of the three faces, and scales them the distance desired\n        let newPlane1 = this.plane;\n        let newPlane2 = faceBefore.plane;\n        let newPlane3 = faceNow.plane;\n\n        newPlane1.scale(height);\n        newPlane2.scale(height);\n        newPlane3.scale(height);\n\n        // Runs three plane intersection on the three planes\n        point = newPlane1.pointOfIntersectionWithPlanes(newPlane2, newPlane3);\n      }\n      \n      // If any two of the three faces are parallel, we try to find three faces that contain the vertex that are not parellel. If this fails, we have a point surrounded by parallel faces,\n      // so we return the point plus the height times the normal of the original face, so the point is directly above where it was by a distance of height.\n      else {\n\n        // A list of the faces that contain the vertex\n        const containsVertex = [];\n\n        // Find all the faces that contain the vertex\n        for (const fac of this.mesh.faces) {\n\n          // Fac has to be different than the original face\n          if (!fac.equals(this)) {\n\n            // Fac must contain vertex\n            if (fac.contains(vertex)) {\n\n              // Add to the list of faces that contain the vertex\n\n              containsVertex.push(fac);\n              \n            }\n          }\n        }\n\n        // Iterate through the faces and find if there are a combination of three that are not parallel.\n\n        // Essentially we need to compute whats known in mathematics as a combination, or n choose r, where n\n        // is the number of things we are choosing from and r is the size of the combination. For this case we don't \n        // know how many faces contain the vertex, so we call that n, and we need 3 faces to find the three_plane_intersection,\n        // so for this case we need n choose 3. We also only need to find one combination of three faces that are not parallel \n        // with each other, so we need to break the loop early if thats the case as we're done, as computing cross products is\n        // expensive and we want to avoid doing it.\n\n        // An array of the indices of containsVertex (from 0 to containsVertex.length - 1)\n        const array = new Array(containsVertex.length).fill(0).map((v, i) => i);\n\n        // Gives a list of the first elements of the combinations, and we have\n        // length - 2 because slice excludes the element of the end index, since we\n        // need two more elements from the last element of the listoffirstelements\n        // to give us a total of three elements, ie if we let listoffirstelements\n        // run across the whole array we'd have outputs where it would loop around from \n        // the end of the array, giving us repeats. We use the indexes so we can preserve\n        // where it is in relation to the whole list, and not have to call a function like\n        // findIndexOf everytime we have an element. We return to the actual elements at the end\n        // when outputting the result.\n\n        const listOfFirstElements = array.slice(0, (array.length - 2));\n\n        let result = '';\n\n        // Use each element of listoffirst elements as the first element of the combination\n        loop1:\n        for (const element of listOfFirstElements) {\n\n          // We need the list of second elements to range from the next element than the current\n          // one of listoffirstelements, to the element before the last, so we can save the last at\n          // the very least for the listofthirdelements to preserve a length of 3 for all combinations\n          const listOfSecondElements = array.slice(element + 1, array.length - 1);\n\n          loop2:\n          // Use each element of listofsecondelements as the second element of the combination\n          for (const el of listOfSecondElements) {\n\n            // We can range the listofthirdelements from the next element from the current element\n            // of listofsecondelements to the end, since we only have three elements in our permutations    \n            const listOfThirdElements = array.slice(el + 1);\n            \n            // If element and el meet some condition, in this case that they are not parallel, \n            // move onto the next one in the loop for listofsecondelements\n            if (cross(containsVertex[element].normal, containsVertex[el].normal) < (epsilon, epsilon, epsilon)) {\n              continue; \n            }\n\n            // We compute the point based on only having two different normals for all the faces that contain the point given.\n            // This corresponds to having a vertex located on an edge, like the edge of a bench. All of the faces that contain\n            // the point either have one normal, for the top of the bench, or another normal, over the edge of the bench, like\n            // in the below diagram.\n            //\n            //\n            //     ^ (first normal)\n            // ----|-----\n            //          |\n            //          | -> (second normal)\n            //          |\n            //          |\n            //\n            // Using trigonometry and the our knowldege of the angle between the normals, the distances above the planes and the \n            // relations between the vectors (ie that the point we need to find is at the opposite point of a kite) we can calculate\n            // the point just based on the two faces. We leave it to be updated in loop3 if we discover a third face that has a different\n            // normal to the first and the second.\n            //\n\n            const angleBetweenNormals = divide(angleBetween(containsVertex[element], containsVertex[el]), 2);\n\n            const c = Math.sqrt(add(Math.sqrt(height), Math.pow(multiply(height, tan(angleBetweenNormals)), 2)));\n\n            const direction = unit(add(containsVertex[element], containsVertex[el]));\n\n            result = add(vertex, multiply(c, direction));\n\n            loop3:\n            // Iterate through the list of third elements to complete our combination\n            for (const l of listOfThirdElements) {\n\n              // If element and l or el and l meet some condition move onto the next one in the loop for listofthirdelements, else make result equal the triplet and break out of the whole loop\n              if ((cross(containsVertex[element].normal, containsVertex[l].normal) < (epsilon, epsilon, epsilon)) || (cross(containsVertex[el].normal, containsVertex[l].normal) < (epsilon, epsilon, epsilon))) { \n                continue;\n\n              }\n\n              // Else make result equal the triplet and break out of the whole loop\n              else {\n                result = [containsVertex[element], containsVertex[el], containsVertex[l]];\n                break loop1;\n              }\n            }\n          }\n        }\n\n        // If we have a point surrounded by parallel faces (so the loop has run through and hasn't updated result, so result will be '', which is false)\n        // then we add the normal of the face times the height to the point, so we make the point above directly above it.\n        if (!result) {\n          point = add(vertex, multiply(height, unit(this.normal)));\n        } \n\n        // If we had the case where we have an edge and only two faces to calculate it from, then the point is just the result. We test this by checking the\n        // size of the first element in the array result - if it is the case where we only have two different normals the length of the first element will\n        // be a single number as it will be the x coordinate, if it has made it through to loop three and updated result with the three different normals\n        // it will be a vector of size 3, not just a number.\n        else if (result[0].length == 1) {\n          point = result;\n        }\n\n        // If we have 3 faces that contain the point and are not parallel\n        else {\n\n          // Creates three new planes identical to the planes of the three faces that we have found that are not parallel, and scales them by the distance desired\n          let resultPlane1 = result[0].plane;\n          let resultPlane2 = result[1].plane;\n          let resultPlane3 = result[2].plane;\n\n          resultPlane1.scale(height);\n          resultPlane2.scale(height);\n          resultPlane3.scale(height);\n          point = resultPlane1.pointOfIntersectionWithPlanes(resultPlane2, resultPlane3);\n          \n        }\n        \n\n      }\n      pointsAbove.push(point);\n    }\n\n    return pointsAbove;\n\n    \n  }\n  \n  // Calculate the dihedrals for a face\n  get dihedrals() {\n\n    // This array will contain three sub arrays (one for each connected face if it exists, if not it will return false),\n    // With the sub arrays containing two values, the dihedral angle and if the edge is a valley or a ridge. A valley is\n    // Where the two faces bend towards each other, like \\/, and a ridge is where they bend away from each other, like /\\.\n    // This becomes important as when creating the struts one needs to tell the difference in order to keep the strut width\n    // The same, otherwise creating a valley as a ridge will cause the struts to be wider, or even incorrect.\n    // Dihedral must not go below 27 degrees for a 2x4 strut\n\n    const dihedrals = [];\n\n    // Iterates through each adjacent face, if it exists, and updates the dihedral and it's type\n    for (const adjacentFace of this.adjacentFaces) {\n\n      // Extract the adjacent face\n      // const adjacentFace = this.adjacentFaces[i];\n\n      // Checks the face exists, if so proceed\n      if (adjacentFace) {\n\n        // Finds the angle between their normals\n        const angle = acos(divide(dot(this.normal, adjacentFace.normal), multiply(norm(this.normal), norm(adjacentFace.normal))));\n\n        // Finds the dihedral angle (interior angle)\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // // Creates a test point to see if the normal direction is inside or outside the tetrahedron formed by the two faces\n        // // Note: assumes face winding has already been performed.\n        // const testpoint = multiply(multiply(epsilon, 2), adjacentFace.normal);\n\n        // // Finds the four points that make up the tetrahedron\n        // const tetrahedron = this.vertices;\n\n        // // Iterate through each of the points in the adjacent face\n        // for (const point of adjacentFace) {\n\n        //   // Check that the point is not in the face and add it to the tetrahedron\n        //   if (!this.contains(point)) tetrahedron.push(point);\n        // }\n\n        // Create a tetrahedron from the points\n\n\n        // If the testpoint is in the tetrahedron, then it returns the dihedral and 'valley', else it returns the dihedral and 'ridge'\n        // PointInsideTetrahedron(tetrahedron, testpoint) ? dihedrals.push([dihedral, 'valley']) : dihedrals.push([dihedral, 'ridge']);\n\n        // Add the dihedrals\n        dihedrals.push({ angle: dihedral, type: 'ridge' });\n\n      } else {\n\n        // The projected normal of the face, projected onto the xz axis\n        const projectedNormal = [this.normal[0], 0, this.normal[2]];\n\n        // Find the angle between the two planes\n        const angle = acos(divide(dot(projectedNormal, this.normal), multiply(norm(projectedNormal), norm(this.normal))));\n\n        // Finds the dihedral from the angle\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // Add the flat dihedral for the bottom struts\n        dihedrals.push({ angle: dihedral, type: null });\n      }\n    }\n\n    // Return the dihedrals\n    return dihedrals;\n  }\n\n  // Calculate the radials for a face\n  get radials() {\n\n    // Create a list of radial angles\n    const radials = [];\n\n    // Iterate through each of the points\n    for (const i in this.vertices) {\n\n      // Define the set of indexes\n      const [i0, i1, i2] = [Number(i), ((Number(i) + 1) % 3), ((Number(i) + 2) % 3)];\n\n      // Multiply the normals (ab, ac)\n      const normals = multiply(norm(subtract(this.vertices[i1], this.vertices[i0])), norm(subtract(this.vertices[i2], this.vertices[i0])));\n\n      // Calculate the radial angle\n      const radial = acos(divide(dot(subtract(this.vertices[i1], this.vertices[i0]), subtract(this.vertices[i2], this.vertices[i0])), normals));\n    \n      // Add the radial angle to the list\n      radials.push(radial);\n    }\n\n    // Return the radials for the face\n    return radials;\n  }\n\n  // Update the indices in the face\n  update([a, b, c]) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Update the indices\n    this[0] = a;\n    this[1] = b;\n    this[2] = c;\n  }\n\n  // Flip the current face\n  flip() {\n\n    // Switch the order from a, b, c to c, b, a\n    this[0] = this[2];\n    this[2] = this[0];\n\n    // Flip the plane\n    this.plane.flip();\n  }\n\n  // Cast the face to a string\n  toString() {\n    \n    // Return the stringified face\n    return JSON.stringify(this);\n  }\n\n  // Evaluate if two faces are the same\n  equals(face) {\n\n    // Throw an error if face is not a Face\n    validate({ face }, 'Face');\n\n    // Check that the faces equal the same value\n    return (this.toString() === face.toString());\n  }\n\n  // Evaluate if the face contains a vertex\n  contains(vertex) {\n\n    // Throw an error if vertex is not a Vertex\n    // Validate({ vertex, Vertex });\n\n    // Find the vertex within the face\n    const match = this.vertices.find(v => v.toString() == JSON.stringify(vertex));\n\n    // Return true if the vertex is in the face\n    return Boolean(match);\n  }\n}"],"file":"face.js"}
=======
{"version":3,"sources":["../../src/shape/face.js"],"names":["validate","Validator","Face","Array","constructor","a","b","c","mesh","species","Symbol","index","Error","Number","faces","findIndex","face","equals","vertices","plane","normal","Direction","scalar","Plane","vertexNormals","edges","Edge","center","Point","area","adjacentFaces","findAdjacentFaceFromEdgeIndex","edgeIndex","i0","i1","i2","faceIndex","edgeCheck","indexOf","otherCheck","pointsAbove","distance","planes","clone","map","i","scale","missingAdjacentIndex","v","vertexIndex","planeFace","planeFaceAB","planeFaceBC","planeFaceCA","pointA","pointOfIntersectionWithPlanes","pointB","pointC","dihedrals","adjacentFace","angle","dihedral","pi","push","type","projectedNormal","radials","normals","radial","update","flip","toString","JSON","stringify","contains","vertex","match","find","Boolean"],"mappings":"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","sourcesContent":["// Import the required math functions\nimport { divide, add, subtract, norm, cross, dot, toMeters, epsilon, pi, acos, multiply, unit } from '@oneisland/math';\n\n// Import the required geometry modules\nimport { Plane } from 'geometry/plane';\nimport { Point } from 'geometry/point';\n\n// Import the required geometry utilities\nimport { Direction } from 'geometry/utils/direction';\n\n// Import the required shape modules\nimport { Edge } from 'shape/edge';\n\n// Imoprt point in polygon function\n// Import { pointInsideTetrahedron } from 'point_inside_tetrahedron.js';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Face');\n\n// Define a class face which is an array of three vertices plus extra properties\nexport class Face extends Array {\n\n  // Bind the indices to the mesh and any mesh\n  constructor([a, b, c], mesh = null) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Throw an error if the mesh in not a Mesh\n    validate({ mesh }, 'Mesh');\n\n    // Call the super function to bind our indices\n    super(a, b, c);\n\n    // Bind the reference to the current mesh if there is one\n    this.mesh = mesh;\n  }\n\n  // Define the species\n  get species() {\n  \n    // Define the species as 'Face'\n    return 'Face';\n  }\n\n  // Define the species to be an array\n  static get [Symbol.species]() {\n    return Array; \n  }\n\n  // Find the index of the face in the mesh faces\n  get index() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the index - the face is not bound to a Mesh`);\n\n    // Return the index of the face in the faces\n    return Number(this.mesh.faces.findIndex(face => face.equals(this)));\n  }\n\n  // Compute the value of vertex a\n  get a() {\n    return this.vertices[0];\n  }\n\n  // Compute the value of vertex b\n  get b() {\n    return this.vertices[1];\n  }\n\n  // Compute the value of vertex c\n  get c() {\n    return this.vertices[2];\n  }\n\n  // Find the vertices for the face based on the indices\n  get vertices() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);\n\n    // Return the vertices based on the indices\n    return [\n      this.mesh.vertices[this[0]], \n      this.mesh.vertices[this[1]], \n      this.mesh.vertices[this[2]]\n    ];  \n  }\n\n  // Find the Plane from a face\n  get plane() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);\n\n    // Calculate the normal of the Plane\n    const normal = new Direction(cross(subtract(this.a, this.b), subtract(this.c, this.b)));\n\n    // Calculate the scalar of the Plane\n    const scalar = dot(normal, this.a);\n\n    // Return the Plane from the Face\n    return new Plane({ normal, scalar });\n  }\n\n  // Compute the normal of the face\n  get normal() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);\n\n    // Return the normal for the face\n    return this.plane.normal;\n  }\n  \n  // Compute the vertex normals\n  get vertexNormals() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the vertex normals of the face - the face is not bound to a Mesh`);\n  }\n\n  // Find the edges from the face\n  get edges() {\n\n    // Return the edges in the face (ab, bc, ca)\n    return [\n      new Edge([this[0], this[1]], this.mesh), \n      new Edge([this[1], this[2]], this.mesh), \n      new Edge([this[2], this[0]], this.mesh)\n    ];\n  }\n\n  // Compute the center of a face\n  get center() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);\n\n    // Calculate the center of the face\n    return new Point(divide(add(this.a, this.b, this.c), 3));\n  }\n\n  // Compute the area of a mesh\n  get area() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);\n  \n    // Calculate the area of a triangle = norm(cross product(a-b, a-c))\n    return toMeters(divide(norm(cross(subtract(this.a, this.b), subtract(this.a, this.c))), 2));\n  }\n\n  // Find the adjacent faces to the face\n  get adjacentFaces() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);\n\n    // Return the list of adjacent faces\n    return [\n      \n      // Find face at edge ab/ba\n      this.findAdjacentFaceFromEdgeIndex(0), \n      \n      // Find face at edge bc/cb\n      this.findAdjacentFaceFromEdgeIndex(1),\n\n      // Find face at edge ca/ac\n      this.findAdjacentFaceFromEdgeIndex(2)\n    ];\n  }\n\n  // Find an adjacent face from an edge index (0: ab, 1: bc, 2: ca)\n  findAdjacentFaceFromEdgeIndex(edgeIndex) {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the adjacent face fom the edge index - the face is not bound to a Mesh`);\n\n    // Determine the vertex which make up the edge\n    const i0 = (edgeIndex);\n    const i1 = ((edgeIndex + 1) % 3);\n\n    // Determine the vertex which is not part of the edge\n    const i2 = ((edgeIndex + 2) % 3);\n\n    // Find the index of the adjacent face\n    const faceIndex = this.mesh.faces.findIndex(face => {\n      \n      // Check that the face contains i0 and i1 (the edge)\n      const edgeCheck = (~face.indexOf(this[i0]) && ~face.indexOf(this[i1]));\n\n      // Check that the face doesn't contain the current index (same face)\n      const otherCheck = (face.indexOf(this[i2]) == -1);\n\n      // Return true if the face is an adjacent face\n      return (edgeCheck && otherCheck);\n    });\n\n    // Return null if there is no face / face index, or return the face\n    return (~faceIndex) ? this.mesh.faces[faceIndex] : null;\n  }\n\n  // Find the face a specific distance above\n  pointsAbove(distance) {\n\n    // Throw an error if distance is not a Number\n    validate({ distance }, 'Number');\n\n    // Create a list of planes (face, faceAB, faceBC, faceCA)\n    const planes = [this.plane.clone(), ...this.adjacentFaces.map(face => ((face) ? face.plane.clone() : null))];\n\n    // Scale each of the planes by the distance\n    for (const i in planes) {\n\n      // Check if there is a plane and scale it by the distance\n      if (planes[i]) planes[i].scale(distance);\n    }\n\n    // Find the index of the non-existing adjacent face if there is one\n    const missingAdjacentIndex = this.adjacentFaces.findIndex(v => v === null);\n\n    // Check if there is a missing face\n    if (~missingAdjacentIndex) {\n\n      // Define which vertex from the edge to use based on which adjacent face is missing (0, 1, 2 == 2, 1, 0)\n      const vertexIndex = (missingAdjacentIndex == 0) ? 2 : (missingAdjacentIndex == 2) ? 0 : missingAdjacentIndex;\n\n      // Creates a new plane that is parallel to the xz plane and contains one point of the edge\n      planes[1 + missingAdjacentIndex] = new Plane({\n        \n        // Calculate the normal\n        normal: new Direction([0, 1, 0]), \n        \n        // Calculate the scalar based on the edge\n        scalar: dot([0, 1, 0], this.vertices[vertexIndex])\n      });\n    }\n\n    // Extract each of the planes\n    const [planeFace, planeFaceAB, planeFaceBC, planeFaceCA] = planes;\n\n    // Finds the three lines of intersection between the original face and the three planes\n    // const lineAB = planeFace.lineOfIntersectionWith(planeFaceAB);\n    // const lineBC = planeFace.lineOfIntersectionWith(planeFaceBC);\n    // const lineCA = planeFace.lineOfIntersectionWith(planeFaceCA);\n\n    // Finds the three points of intersection between the three lines\n    // const pointA = lineAB.pointOfIntersectionWithLine(lineCA);\n    // const pointB = lineBC.pointOfIntersectionWithLine(lineAB);\n    // const pointC = lineCA.pointOfIntersectionWithLine(lineBC);\n\n    // Find the point of intersection between three faces\n    const pointA = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceCA);\n    const pointB = planeFace.pointOfIntersectionWithPlanes(planeFaceAB, planeFaceBC);\n    const pointC = planeFace.pointOfIntersectionWithPlanes(planeFaceBC, planeFaceCA);\n\n    // Return three points above\n    return [pointA, pointB, pointC];\n  }\n  \n  // Calculate the dihedrals for a face\n  get dihedrals() {\n\n    // This array will contain three sub arrays (one for each connected face if it exists, if not it will return false),\n    // With the sub arrays containing two values, the dihedral angle and if the edge is a valley or a ridge. A valley is\n    // Where the two faces bend towards each other, like \\/, and a ridge is where they bend away from each other, like /\\.\n    // This becomes important as when creating the struts one needs to tell the difference in order to keep the strut width\n    // The same, otherwise creating a valley as a ridge will cause the struts to be wider, or even incorrect.\n    // Dihedral must not go below 27 degrees for a 2x4 strut\n\n    const dihedrals = [];\n\n    // Iterates through each adjacent face, if it exists, and updates the dihedral and it's type\n    for (const adjacentFace of this.adjacentFaces) {\n\n      // Extract the adjacent face\n      // const adjacentFace = this.adjacentFaces[i];\n\n      // Checks the face exists, if so proceed\n      if (adjacentFace) {\n\n        // Finds the angle between their normals\n        const angle = acos(divide(dot(this.normal, adjacentFace.normal), multiply(norm(this.normal), norm(adjacentFace.normal))));\n\n        // Finds the dihedral angle (interior angle)\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // // Creates a test point to see if the normal direction is inside or outside the tetrahedron formed by the two faces\n        // // Note: assumes face winding has already been performed.\n        // const testpoint = multiply(multiply(epsilon, 2), adjacentFace.normal);\n\n        // // Finds the four points that make up the tetrahedron\n        // const tetrahedron = this.vertices;\n\n        // // Iterate through each of the points in the adjacent face\n        // for (const point of adjacentFace) {\n\n        //   // Check that the point is not in the face and add it to the tetrahedron\n        //   if (!this.contains(point)) tetrahedron.push(point);\n        // }\n\n        // Create a tetrahedron from the points\n\n\n        // If the testpoint is in the tetrahedron, then it returns the dihedral and 'valley', else it returns the dihedral and 'ridge'\n        // PointInsideTetrahedron(tetrahedron, testpoint) ? dihedrals.push([dihedral, 'valley']) : dihedrals.push([dihedral, 'ridge']);\n\n        // Add the dihedrals\n        dihedrals.push({ angle: dihedral, type: 'ridge' });\n\n      } else {\n\n        // The projected normal of the face, projected onto the xz axis\n        const projectedNormal = [this.normal[0], 0, this.normal[2]];\n\n        // Find the angle between the two planes\n        const angle = acos(divide(dot(projectedNormal, this.normal), multiply(norm(projectedNormal), norm(this.normal))));\n\n        // Finds the dihedral from the angle\n        const dihedral = divide(subtract(pi, angle), 2);\n\n        // Add the flat dihedral for the bottom struts\n        dihedrals.push({ angle: dihedral, type: null });\n      }\n    }\n\n    // Return the dihedrals\n    return dihedrals;\n  }\n\n  // Calculate the radials for a face\n  get radials() {\n\n    // Create a list of radial angles\n    const radials = [];\n\n    // Iterate through each of the points\n    for (const i in this.vertices) {\n\n      // Define the set of indexes\n      const [i0, i1, i2] = [Number(i), ((Number(i) + 1) % 3), ((Number(i) + 2) % 3)];\n\n      // Multiply the normals (ab, ac)\n      const normals = multiply(norm(subtract(this.vertices[i1], this.vertices[i0])), norm(subtract(this.vertices[i2], this.vertices[i0])));\n\n      // Calculate the radial angle\n      const radial = acos(divide(dot(subtract(this.vertices[i1], this.vertices[i0]), subtract(this.vertices[i2], this.vertices[i0])), normals));\n    \n      // Add the radial angle to the list\n      radials.push(radial);\n    }\n\n    // Return the radials for the face\n    return radials;\n  }\n\n  // Update the indices in the face\n  update([a, b, c]) {\n\n    // Throw an error if a, b or c is not a Number\n    validate({ a, b, c }, 'Number');\n\n    // Update the indices\n    this[0] = a;\n    this[1] = b;\n    this[2] = c;\n  }\n\n  // Flip the current face\n  flip() {\n\n    // Switch the order from a, b, c to c, b, a\n    this[0] = this[2];\n    this[2] = this[0];\n\n    // Flip the plane\n    this.plane.flip();\n  }\n\n  // Cast the face to a string\n  toString() {\n    \n    // Return the stringified face\n    return JSON.stringify(this);\n  }\n\n  // Evaluate if two faces are the same\n  equals(face) {\n\n    // Throw an error if face is not a Face\n    validate({ face }, 'Face');\n\n    // Check that the faces equal the same value\n    return (this.toString() === face.toString());\n  }\n\n  // Evaluate if the face contains a vertex\n  contains(vertex) {\n\n    // Throw an error if vertex is not a Vertex\n    // Validate({ vertex, Vertex });\n\n    // Find the vertex within the face\n    const match = this.vertices.find(v => v.toString() == JSON.stringify(vertex));\n\n    // Return true if the vertex is in the face\n    return Boolean(match);\n  }\n}"],"file":"face.js"}
>>>>>>> 908221ad1438cb7cfcf313f6bf0247242f28c777
