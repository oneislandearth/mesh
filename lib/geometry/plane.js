"use strict";exports.__esModule=true;exports.Plane=void 0;var _math=require("../utils/math");var _line=require("./line");var _point=require("./point");var _polygon=require("./polygon");var _direction=require("./utils/direction");var _validator=require("../utils/validator");const{validate}=new _validator.Validator("Plane");class Plane{constructor({normal,scalar}){validate({normal,Direction:_direction.Direction});validate({scalar,Number});this.normal=normal;this.scalar=scalar}static get tolerance(){return 1e-4}static fromPolygon(polygon){validate({polygon,Polygon:_polygon.Polygon});const normal=new _direction.Direction((0,_math.cross)((0,_math.subtract)(polygon[1],polygon[0]),(0,_math.subtract)(polygon[2],polygon[0])));const scalar=(0,_math.dot)(normal,polygon[0]);return new Plane({normal,scalar})}flip(){this.normal=(0,_math.multiply)(this.normal,-1);this.scalar=(0,_math.multiply)(this.scalar,-1)}scale(distance){validate({distance,Number});this.scalar=(0,_math.add)(this.scalar,distance)}containsPoint(point){return(0,_math.subtract)(this.scalar,(0,_math.dot)(this.normal,point))<=Plane.tolerance}lineOfIntersectionWith(plane){validate({plane,Plane});const[n1,s1]=[this.normal,this.scalar];const[n2,s2]=[plane.normal,plane.scalar];const direction=(0,_math.cross)(n1,n2);if(direction==0)return null;const c1=(0,_math.divide)((0,_math.subtract)(s1,(0,_math.multiply)(s2,(0,_math.dot)(n1,n2))),(0,_math.subtract)(1,(0,_math.multiply)((0,_math.dot)(n1,n2),(0,_math.dot)(n1,n2))));const c2=(0,_math.divide)((0,_math.subtract)(s2,(0,_math.multiply)(s1,(0,_math.dot)(n1,n2))),(0,_math.subtract)(1,(0,_math.multiply)((0,_math.dot)(n1,n2),(0,_math.dot)(n1,n2))));const point=(0,_math.add)((0,_math.multiply)(c1,n1),(0,_math.multiply)(c2,n2));return new _line.Line({point:new _point.Point(point),direction:new _direction.Direction(direction)})}}exports.Plane=Plane;