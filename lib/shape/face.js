"use strict";exports.__esModule=true;exports.Face=void 0;var _math=require("../utils/math");var _plane=require("../geometry/plane");var _point=require("../geometry/point");var _direction=require("../geometry/utils/direction");var _edge=require("./edge");var _vertex=require("./vertex");var _mesh=require("../mesh/mesh");var _validator=require("../utils/validator");const{validate}=new _validator.Validator("Face");class Face extends Array{constructor([a,b,c],mesh=null){validate({a,Number});validate({b,Number});validate({c,Number});if(mesh)validate({mesh,Mesh:_mesh.Mesh});super([a,b,c]);this.mesh=mesh}static get[Symbol.species](){return Array}get a(){return this.vertices[0]}get b(){return this.vertices[1]}get c(){return this.vertices[2]}get vertices(){if(!this.mesh)throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);return[this.mesh.vertices[this[0]],this.mesh.vertices[this[1]],this.mesh.vertices[this[2]]]}get plane(){if(!this.mesh)throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);const normal=new _direction.Direction((0,_math.cross)((0,_math.minus)(this.b,this.a),(0,_math.minus)(this.c,this.a)));const scalar=(0,_math.dot)(normal,this.a);return new _plane.Plane({normal,scalar})}get normal(){if(!this.mesh)throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);return this.plane.normal}get edges(){return[new _edge.Edge([this.a,this.b],this.mesh),new _edge.Edge([this.b,this.c],this.mesh),new _edge.Edge([this.c,this.a],this.mesh)]}get center(){if(!this.mesh)throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);return new _point.Point((0,_math.divide)((0,_math.add)(this.a,this.b,this.c),3))}get area(){if(!this.mesh)throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);return(0,_math.toMeters)((0,_math.divide)((0,_math.norm)((0,_math.cross)((0,_math.subtract)(this.a,this.b),(0,_math.subtract)(this.a,this.c))),2))}get adjacentFaces(){if(!this.mesh)throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);const adjacentFaces=[null,null,null];const[edgeAB,edgeBC,edgeCA]=this.edges;for(const face of this.mesh.faces){const adjacentEdge=this.adjacentFaces(face);if(!adjacentEdge)continue;if(adjacentEdge.equals(edgeAB))adjacentFaces[0]=face;if(adjacentEdge.equals(edgeBC))adjacentFaces[1]=face;if(adjacentEdge.equals(edgeCA))adjacentFaces[2]=face}return adjacentFaces}adjacentEdge(face){validate({face,Face});const[edgeAB,edgeBC,edgeCA]=this.edges;for(const edge of face.edges){if(edge.equals(edgeAB)||edge.equals(edgeBC)||edge.equals(edgeCA))return edge}return null}reorder(order){const equals=order=>{let sum=0;const valid=[0,1,2];for(const value of order){sum+=valid.indexOf(Number(value))}return sum==3};validate({order,equals,expects:"\"order\" to be a valid order of indices (0, 1, 2)"});console.log(order);this[0]=this[order[0]];this[1]=this[order[1]];this[2]=this[order[2]]}flip(){this[0]=this[2];this[2]=this[0];this.plane.flip()}toString(){return JSON.stringify(this)}equals(face){validate({face,Face});return this.toString()===face.toString()}contains(vertex){validate({vertex,Vertex:_vertex.Vertex});const match=this.vertices.filter(v=>v.toString()==vertex.toString());return Boolean(match)}}exports.Face=Face;