{"version":3,"sources":["../../src/shape/vertex.js"],"names":["validate","Validator","Vertex","Point","constructor","x","y","z","mesh","normal","species","Symbol","Array","index","Error","Number","vertices","findIndex","vertex","equals","updateNormal","toPoint","toVector","Vector"],"mappings":"2DACA,wCACA,0CAGA,+CAGA,KAAM,CAAEA,QAAF,EAAe,GAAIC,qBAAJ,CAAc,QAAd,CAArB,CAGO,KAAMC,CAAAA,MAAN,QAAqBC,aAAM,CAGhCC,WAAW,CAAC,CAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAD,CAAYC,IAAI,CAAG,IAAnB,CAAyB,CAGlCR,QAAQ,CAAC,CAAEK,CAAF,CAAKC,CAAL,CAAQC,CAAR,CAAD,CAAc,QAAd,CAAR,CAGAP,QAAQ,CAAC,CAAEQ,IAAF,CAAD,CAAW,MAAX,CAAR,CAGA,MAAM,CAACH,CAAD,CAAIC,CAAJ,CAAOC,CAAP,CAAN,EAGA,KAAKC,IAAL,CAAYA,IAAZ,CAGA,KAAKC,MAAL,CAAc,IACf,CAGD,GAAIC,CAAAA,OAAJ,EAAc,CAGZ,MAAO,QACR,CAGD,WAAYC,MAAM,CAACD,OAAnB,GAA8B,CAC5B,MAAOE,CAAAA,KACR,CAGD,GAAIC,CAAAA,KAAJ,EAAY,CAGV,GAAI,CAAC,KAAKL,IAAV,CAAgB,KAAM,IAAIM,CAAAA,KAAJ,CAAW,8DAAX,CAAN,CAGhB,MAAOC,CAAAA,MAAM,CAAC,KAAKP,IAAL,CAAUQ,QAAV,CAAmBC,SAAnB,CAA6BC,MAAM,EAAIA,MAAM,CAACC,MAAP,CAAc,IAAd,CAAvC,CAAD,CACd,CAGDC,YAAY,CAACX,MAAD,CAAS,CAGnB,KAAKA,MAAL,CAAcA,MACf,CAGDY,OAAO,EAAG,CAGR,MAAO,IAAIlB,aAAJ,CAAU,CAAC,KAAKE,CAAN,CAAS,KAAKC,CAAd,CAAiB,KAAKC,CAAtB,CAAV,CACR,CAGDe,QAAQ,EAAG,CAGT,MAAO,IAAIC,eAAJ,CAAW,CAAC,KAAKlB,CAAN,CAAS,KAAKC,CAAd,CAAiB,KAAKC,CAAtB,CAAX,CACR,CA9D+B,C","sourcesContent":["// Import the required geometry modules\nimport { Point } from 'geometry/point';\nimport { Vector } from 'geometry/vector';\n\n// Import the required utilities\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Vertex');\n\n// Creates a Vertex within a Mesh\nexport class Vertex extends Point {\n\n  // Create a Vertex from the x, y, z coordinates\n  constructor([x, y, z], mesh = null) {\n\n    // Throw an error if the x, y or z value is not a Number\n    validate({ x, y, z }, 'Number',);\n\n    // Throw an error if the mesh in not a Mesh\n    validate({ mesh }, 'Mesh');\n\n    // Pass the coordianted to the super function\n    super([x, y, z]);\n\n    // Bind the reference to the current mesh if there is one\n    this.mesh = mesh;\n\n    // Define the vertex normal\n    this.normal = null;\n  }\n\n  // Define the species\n  get species() {\n    \n    // Define the species as 'Vertex'\n    return 'Vertex';\n  }\n\n  // Define the species to be an array\n  static get [Symbol.species]() {\n    return Array; \n  }\n\n  // Find the index of the vertex in the mesh vertices\n  get index() {\n\n    // Check if the face is bound to a mesh and if not throw an error\n    if (!this.mesh) throw new Error(`Cannot compute the index - the vertex is not bound to a Mesh`);\n\n    // Return the index of the vertex in the vertices\n    return Number(this.mesh.vertices.findIndex(vertex => vertex.equals(this)));\n  }\n\n  // Update the vertex normal\n  updateNormal(normal) {\n\n    // Update the normal of the vertex\n    this.normal = normal;\n  }\n\n  // Cast the Vertex to a Point\n  toPoint() {\n\n    // Return a new Point\n    return new Point([this.x, this.y, this.z]);\n  }\n\n  // Cast the Vertex to a Vector\n  toVector() {\n\n    // Return a new Vector\n    return new Vector([this.x, this.y, this.z]);\n  }\n\n}"],"file":"vertex.js"}