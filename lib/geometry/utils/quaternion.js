"use strict";exports.__esModule=true;exports.Quaternion=void 0;var _math=require("@oneisland/math");var _vector=require("../vector");var _angle=require("./angle");var _direction=require("./direction");var _validator=require("@oneisland/validator");const{validate}=new _validator.Validator("Quaternion");class Quaternion extends Array{constructor({scalar,vector}){validate({scalar},"Number");validate({vector},"Vector");super(scalar,...vector)}get species(){return"Quaternion"}static fromVector({vector}){validate({vector},"Vector");return new Quaternion({scalar:0,vector})}static fromAngleAndDirection({angle,direction}){validate({angle},"Angle");validate({direction},"Direction");const[x,y,z]=direction;return new Quaternion({scalar:(0,_math.cos)((0,_math.divide)(angle,2)),vector:new _vector.Vector([(0,_math.multiply)((0,_math.sin)((0,_math.divide)(angle,2)),x),(0,_math.multiply)((0,_math.sin)((0,_math.divide)(angle,2)),y),(0,_math.multiply)((0,_math.sin)((0,_math.divide)(angle,2)),z)])})}multiply(quaternion){validate({quaternion},"Quaternion");const[s1,v1]=[this.scalar,this.vector];const[s2,v2]=[quaternion.scalar,quaternion.vector];return new Quaternion({scalar:(0,_math.subtract)((0,_math.multiply)(s1,s2),(0,_math.dot)(v1,v2)),vector:new _vector.Vector((0,_math.add)((0,_math.add)((0,_math.multiply)(s1,v2),(0,_math.multiply)(s2,v1)),(0,_math.cross)(v1,v2)))})}static get[Symbol.species](){return Array}get scalar(){return this[0]}get vector(){return new _vector.Vector(this[1],this[2],this[3])}}exports.Quaternion=Quaternion;