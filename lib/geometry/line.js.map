{"version":3,"sources":["../../src/geometry/line.js"],"names":["validate","Validator","Line","constructor","point","direction","species","fromPoints","a","b","Direction","pointFromDistance","distance","Point","lineFromDistance","pointOfIntersectionWithPlane","plane","normal","scalar","pointOfIntersectionWithLine","line","crossDirection","crossDistance","front","intersection"],"mappings":"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","sourcesContent":["// Import the required math functions\nimport { add, multiply, cross, subtract, divide, dot, norm, isZeroes } from '@oneisland/math';\n\n// Import the required geometry modules\nimport { Point } from 'geometry/point';\nimport { Plane } from 'geometry/plane';\n\n// Import the required geometry utiliites\nimport { Direction } from 'geometry/utils/direction';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Line');\n\n// Create a line from a Point and Direction\nexport class Line {\n\n  // Bind the point and direction\n  constructor({ point, direction }) {\n\n    // Throw an error if the point is not a Point\n    validate({ point }, ['Point', 'Vertex']);\n\n    // Throw an error if the direction is not a Direction\n    validate({ direction }, 'Direction');\n\n    // Bind the point and direction\n    this.point = point;\n    this.direction = direction;\n  }\n\n  // Define the species\n  get species() {\n\n    // Define the species as 'Line'\n    return 'Line';\n  }\n\n  // Create a new line from two points\n  static fromPoints([a, b]) {\n\n    // Throw an error if a or b is not a Point\n    validate({ a, b }, ['Point', 'Vertex']);\n\n    // Return the new Line\n    return new Line({\n\n      // Add the point\n      point: a,\n\n      // Add the direction\n      direction: new Direction(subtract(b, a))\n    });\n  }\n\n  // Create a new Point from a line distance\n  pointFromDistance(distance) {\n\n    // Throw an error if the distance is not a Number\n    validate({ distance }, 'Number');\n\n    // Calculate the new point from the distance\n    const point = add(this.point, multiply(distance, this.direction));\n\n    // Return a new Point along the line\n    return new Point(point);\n  }\n\n  // Create a new Line from a line distance\n  lineFromDistance(distance) {\n\n    // Throw an error if the distance is not a Number\n    validate({ distance }, 'Number');\n\n    // Return a new Line along the line\n    return new Line({ \n\n      // Add the point\n      point: this.pointFromDistance(distance),\n\n      // Add the direction\n      direction: this.direction\n    });\n  }\n\n  // Calculate the point of intersection with a plane\n  pointOfIntersectionWithPlane(plane) {\n\n    // Throw an error if plane is not a Plane\n    validate({ plane }, 'Plane');\n\n    // Return if there is no intersection between the line and plane\n    if (dot(plane.normal, this.direction)) return null;\n\n    // Calculate the distance along the line where the line intercepts the plane\n    const distance = divide(subtract(plane.scalar, dot(plane.normal, this.point)), dot(plane.normal, this.direction));\n\n    // Return the point of intersection\n    return this.pointFromDistance(distance);\n  }\n\n  // Calculate the point of intersection another line\n  pointOfIntersectionWithLine(line) {\n\n    // Throw an error if line is not a Line\n    validate({ line }, 'Line');\n\n    // Calculate the cross product of the direction\n    const crossDirection = cross(line.direction, this.direction);\n\n    // Calculate the cross product of the distance\n    const crossDistance = cross(line.direction, subtract(this.point, line.point));\n\n    // Return if there is no intersection between the two lines\n    if (isZeroes(crossDistance) || isZeroes(crossDirection)) return null;    \n\n    // Vector of distance to the intersection\n    const distance = multiply(divide(norm(crossDistance), norm(crossDirection)), this.direction);\n\n    // Check whether the point is in front or behind the point on a line \n    const front = (dot(crossDistance, crossDirection) > 0);\n\n    // Calculate the point of intersection based on whether the point is in front or not\n    const intersection = (front) ? add(this.point, distance) : subtract(this.point, distance);\n\n    // Return the point of intersection\n    return new Point(intersection);\n  }\n}"],"file":"line.js"}