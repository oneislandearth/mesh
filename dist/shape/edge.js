"use strict";exports.__esModule=true;exports.Edge=void 0;var _math=require("../utils/math");var _line=require("../geometry/line");var _point=require("../geometry/point");var _direction=require("../geometry/utils/direction");var _vertex=require("./vertex");var _mesh=require("../shapes/mesh");var _validator=require("../utils/validator");const{validate}=new _validator.Validator("Edge");class Edge extends Array{constructor([a,b],mesh=null){validate({a,Number});validate({b,Number});if(mesh)validate({mesh,Mesh:_mesh.Mesh});super(a,b);this.mesh=mesh}static get[Symbol.species](){return Array}get a(){return this.vertices[0]}get b(){return this.vertices[1]}get vertices(){if(!this.mesh)throw new Error(`Cannot compute the vertices - the edge is not bound to a Mesh`);return[this.mesh.vertices[this[0]],this.mesh.vertices[this[1]]]}get length(){if(!this.mesh)throw new Error(`Cannot compute the length of the edge - the edge is not bound to a Mesh`);return(0,_math.toMeters)((0,_math.distance)(this.a,this.b))}get direction(){if(!this.mesh)throw new Error(`Cannot compute the direction of the edge - the edge is not bound to a Mesh`);return new _direction.Direction((0,_math.subtract)(this.b,this.a))}lerp(fraction){if(!this.mesh)throw new Error(`Cannot compute linear interpolation of the edge - the edge is not bound to a Mesh`);return new _point.Point((0,_math.multiply)(fraction,(0,_math.subtract)(this.b,this.a)))}toLine(){return new _line.Line({point:new _point.Point(this.a),direction:new _direction.Direction((0,_math.subtract)(this.b,this.a))})}toString(){return JSON.stringify(this)}equals(edge){validate({edge,Edge});return this.toString()===edge.toString()}contains(vertex){validate({vertex,Vertex:_vertex.Vertex});const match=this.vertices.filter(v=>v.toString()==vertex.toString());return Boolean(match)}}exports.Edge=Edge;