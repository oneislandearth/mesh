"use strict";exports.__esModule=true;exports.Face=void 0;var _math=require("@oneisland/math");var _plane=require("../geometry/plane");var _point=require("../geometry/point");var _direction=require("../geometry/utils/direction");var _edge=require("./edge");var _validator=require("@oneisland/validator");const{validate}=new _validator.Validator("Face");class Face extends Array{constructor([a,b,c],mesh=null){validate({a,b,c},"Number");validate({mesh},"Mesh");super(a,b,c);this.mesh=mesh}get species(){return"Face"}static get[Symbol.species](){return Array}get index(){if(!this.mesh)throw new Error(`Cannot compute the index - the face is not bound to a Mesh`);return Number(this.mesh.faces.findIndex(face=>face.equals(this)))}get a(){return this.vertices[0]}get b(){return this.vertices[1]}get c(){return this.vertices[2]}get vertices(){if(!this.mesh)throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);return[this.mesh.vertices[this[0]],this.mesh.vertices[this[1]],this.mesh.vertices[this[2]]]}get plane(){if(!this.mesh)throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);const normal=new _direction.Direction((0,_math.cross)((0,_math.subtract)(this.a,this.b),(0,_math.subtract)(this.c,this.b)));const scalar=(0,_math.dot)(normal,this.a);return new _plane.Plane({normal,scalar})}get normal(){if(!this.mesh)throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);return this.plane.normal}get vertexNormals(){if(!this.mesh)throw new Error(`Cannot compute the vertex normals of the face - the face is not bound to a Mesh`)}get edges(){return[new _edge.Edge([this[0],this[1]],this.mesh),new _edge.Edge([this[1],this[2]],this.mesh),new _edge.Edge([this[2],this[0]],this.mesh)]}get center(){if(!this.mesh)throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);return new _point.Point((0,_math.divide)((0,_math.add)(this.a,this.b,this.c),3))}get area(){if(!this.mesh)throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);return(0,_math.toMeters)((0,_math.divide)((0,_math.norm)((0,_math.cross)((0,_math.subtract)(this.a,this.b),(0,_math.subtract)(this.a,this.c))),2))}get adjacentFaces(){if(!this.mesh)throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);return[this.findAdjacentFaceFromEdgeIndex(0),this.findAdjacentFaceFromEdgeIndex(1),this.findAdjacentFaceFromEdgeIndex(2)]}findAdjacentFaceFromEdgeIndex(edgeIndex){if(!this.mesh)throw new Error(`Cannot compute the adjacent face fom the edge index - the face is not bound to a Mesh`);const i0=edgeIndex;const i1=(edgeIndex+1)%3;const i2=(edgeIndex+2)%3;const faceIndex=this.mesh.faces.findIndex(face=>{const edgeCheck=~face.indexOf(this[i0])&&~face.indexOf(this[i1]);const otherCheck=face.indexOf(this[i2])==-1;return edgeCheck&&otherCheck});return~faceIndex?this.mesh.faces[faceIndex]:null}pointsAbove(height){const pointsAbove=[];const planes=this.adjacentFaces.map(face=>face?face.plane:null);const missingAdjacentIndex=planes.findIndex(v=>v===null);if(~missingAdjacentIndex){const vertexIndex=missingAdjacentIndex==0?2:missingAdjacentIndex==2?0:missingAdjacentIndex;planes[missingAdjacentIndex]=new _plane.Plane({normal:new _direction.Direction([0,1,0]),scalar:(0,_math.dot)([0,1,0],this.vertices[vertexIndex])})}for(const[index,vertex]of Object.entries(this.vertices)){let point=[];const facePlane=this.plane.clone();const adjacentPlane=planes[index].clone();const previousAdjacentPlane=planes[(index+(this.vertices.length-1))%this.vertices.length].clone();if(!(0,_math.isZeroes)((0,_math.cross)(adjacentPlane.normal,previousAdjacentPlane.normal))&&!(0,_math.isZeroes)((0,_math.cross)(facePlane.normal,previousAdjacentPlane.normal))&&!(0,_math.isZeroes)((0,_math.cross)(adjacentPlane.normal,facePlane.normal))){facePlane.scale(height);previousAdjacentPlane.scale(height);adjacentPlane.scale(height);point=facePlane.pointOfIntersectionWithPlanes(adjacentPlane,previousAdjacentPlane)}else{const containsVertex=[];for(const fac of this.mesh.faces){if(!fac.equals(this)){if(fac.contains(vertex)){containsVertex.push(fac)}}}const array=new Array(containsVertex.length).fill(0).map((v,i)=>i);const listOfFirstElements=array.slice(0,array.length-2);let result="";loop1:for(const element of listOfFirstElements){const listOfSecondElements=array.slice(element+1,array.length-1);loop2:for(const el of listOfSecondElements){const listOfThirdElements=array.slice(el+1);if((0,_math.norm)((0,_math.cross)(containsVertex[element].normal,containsVertex[el].normal))<_math.epsilon){continue}const angleBetweenNormals=(0,_math.divide)((0,_math.angleBetween)(containsVertex[element],containsVertex[el]),2);const c=Math.sqrt((0,_math.add)(Math.sqrt(height),Math.pow((0,_math.multiply)(height,(0,_math.tan)(angleBetweenNormals)),2)));const direction=(0,_math.unit)((0,_math.add)(containsVertex[element],containsVertex[el]));result=(0,_math.add)(vertex,(0,_math.multiply)(c,direction));loop3:for(const l of listOfThirdElements){if((0,_math.norm)((0,_math.cross)(containsVertex[element].normal,containsVertex[l].normal))<_math.epsilon||(0,_math.norm)((0,_math.cross)(containsVertex[el].normal,containsVertex[l].normal))<_math.epsilon){continue}else{result=[containsVertex[element],containsVertex[el],containsVertex[l]];break loop1}}}}if(!result){point=(0,_math.add)(vertex,(0,_math.multiply)(height,(0,_math.unit)(this.normal)))}else if(result[0].length==1){point=result}else{const resultPlane1=result[0].plane;const resultPlane2=result[1].plane;const resultPlane3=result[2].plane;resultPlane1.scale(height);resultPlane2.scale(height);resultPlane3.scale(height);point=resultPlane1.pointOfIntersectionWithPlanes(resultPlane2,resultPlane3)}}pointsAbove.push(point)}return pointsAbove}get dihedrals(){const dihedrals=[];for(const adjacentFace of this.adjacentFaces){if(adjacentFace){const angle=(0,_math.acos)((0,_math.divide)((0,_math.dot)(this.normal,adjacentFace.normal),(0,_math.multiply)((0,_math.norm)(this.normal),(0,_math.norm)(adjacentFace.normal))));const dihedral=(0,_math.divide)((0,_math.subtract)(_math.pi,angle),2);dihedrals.push({angle:dihedral,type:"ridge"})}else{const projectedNormal=[this.normal[0],0,this.normal[2]];const angle=(0,_math.acos)((0,_math.divide)((0,_math.dot)(projectedNormal,this.normal),(0,_math.multiply)((0,_math.norm)(projectedNormal),(0,_math.norm)(this.normal))));const dihedral=(0,_math.divide)((0,_math.subtract)(_math.pi,angle),2);dihedrals.push({angle:dihedral,type:null})}}return dihedrals}get radials(){const radials=[];for(const i in this.vertices){const[i0,i1,i2]=[Number(i),(Number(i)+1)%3,(Number(i)+2)%3];const normals=(0,_math.multiply)((0,_math.norm)((0,_math.subtract)(this.vertices[i1],this.vertices[i0])),(0,_math.norm)((0,_math.subtract)(this.vertices[i2],this.vertices[i0])));const radial=(0,_math.acos)((0,_math.divide)((0,_math.dot)((0,_math.subtract)(this.vertices[i1],this.vertices[i0]),(0,_math.subtract)(this.vertices[i2],this.vertices[i0])),normals));radials.push(radial)}return radials}update([a,b,c]){validate({a,b,c},"Number");this[0]=a;this[1]=b;this[2]=c}flip(){this[0]=this[2];this[2]=this[0];this.plane.flip()}toString(){return JSON.stringify(this)}equals(face){validate({face},"Face");return this.toString()===face.toString()}contains(vertex){const match=this.vertices.find(v=>v.toString()==JSON.stringify(vertex));return Boolean(match)}}exports.Face=Face;
//# sourceMappingURL=face.js.map