"use strict";exports.__esModule=true;exports.Face=void 0;var _math=require("@oneisland/math");var _plane=require("../geometry/plane");var _point=require("../geometry/point");var _direction=require("../geometry/utils/direction");var _edge=require("./edge");var _validator=require("@oneisland/validator");const{validate}=new _validator.Validator("Face");class Face extends Array{constructor([a,b,c],mesh=null){validate({a,b,c},"Number");validate({mesh},"Mesh");super(a,b,c);this.mesh=mesh}get species(){return"Face"}static get[Symbol.species](){return Array}get index(){if(!this.mesh)throw new Error(`Cannot compute the index - the face is not bound to a Mesh`);return Number(this.mesh.faces.findIndex(face=>face.equals(this)))}get a(){return this.vertices[0]}get b(){return this.vertices[1]}get c(){return this.vertices[2]}get vertices(){if(!this.mesh)throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);return[this.mesh.vertices[this[0]],this.mesh.vertices[this[1]],this.mesh.vertices[this[2]]]}get plane(){if(!this.mesh)throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);const normal=new _direction.Direction((0,_math.cross)((0,_math.subtract)(this.b,this.a),(0,_math.subtract)(this.c,this.a)));const scalar=(0,_math.dot)(normal,this.a);return new _plane.Plane({normal,scalar})}get normal(){if(!this.mesh)throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);return this.plane.normal}get edges(){return[new _edge.Edge([this[0],this[1]],this.mesh),new _edge.Edge([this[1],this[2]],this.mesh),new _edge.Edge([this[2],this[0]],this.mesh)]}get center(){if(!this.mesh)throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);return new _point.Point((0,_math.divide)((0,_math.add)(this.a,this.b,this.c),3))}get area(){if(!this.mesh)throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);return(0,_math.toMeters)((0,_math.divide)((0,_math.norm)((0,_math.cross)((0,_math.subtract)(this.a,this.b),(0,_math.subtract)(this.a,this.c))),2))}get adjacentFaces(){if(!this.mesh)throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);return[this.findAdjacentFaceFromEdgeIndex(0),this.findAdjacentFaceFromEdgeIndex(1),this.findAdjacentFaceFromEdgeIndex(2)]}findAdjacentFaceFromEdgeIndex(edgeIndex){if(!this.mesh)throw new Error(`Cannot compute the adjacent face fom the edge index - the face is not bound to a Mesh`);const i0=edgeIndex;const i1=(edgeIndex+1)%3;const i2=(edgeIndex+2)%3;const faceIndex=this.mesh.faces.findIndex(face=>{const edgeCheck=~face.indexOf(this[i0])&&~face.indexOf(this[i1]);const otherCheck=face.indexOf(this[i2])==-1;return edgeCheck&&otherCheck});return~faceIndex?this.mesh.faces[faceIndex]:null}update([a,b,c]){this[0]=a;this[1]=b;this[2]=c}flip(){this[0]=this[2];this[2]=this[0];this.plane.flip()}toString(){return JSON.stringify(this)}equals(face){validate({face},"Face");return this.toString()===face.toString()}contains(vertex){const match=this.vertices.filter(v=>v.toString()==vertex.toString());return Boolean(match)}}exports.Face=Face;