"use strict";exports.__esModule=true;exports.Polygon=void 0;var _math=require("@oneisland/math");var _plane=require("./plane");var _point=require("./point");var _validator=require("@oneisland/validator");const{validate,validateAll}=new _validator.Validator("Polygon");class Polygon extends Array{constructor(points){validate({points},p=>p.length>2,`"points" to contain at least three points`);validateAll({points},["Point","Vertex"],`"points" to be an array of Point instances`);super(...points)}get species(){return"Polygon"}get plane(){return _plane.Plane.fromPolygon(this)}get normal(){return this.plane.normal}get area(){return(0,_math.abs)(this.signedArea)}signedArea(normal){let sum=[0,0,0];for(const i in this){const pi=this[i];const pn=this[(i+1)%this.length];sum=(0,_math.add)(sum,(0,_math.cross)(pi,pn))}return(0,_math.divide)((0,_math.dot)(normal?normal:this.plane.normal,sum),2)}get clockwise(){if(this.signedArea()>=0)return true;return false}flip(){this.plane.flip()}containsPoint(point){if(!this.plane.containsPoint(point))return false;let inside=0;const projectionIndex=this.normal.findIndex(value=>value==(0,_math.max)(...this.normal));const pointProjected=point.projectToPlane(this.plane).filter((v,index)=>index!=projectionIndex);const polygonProjected=[...this].map(polygon=>polygon.filter((v,index)=>index!=projectionIndex));const[x,y]=pointProjected;let j=polygonProjected.length-1;for(const i in polygonProjected){const[xi,yi]=polygonProjected[i];const[xj,yj]=polygonProjected[j];if(yi<=y&&yj>y||yj<=y&&yi>y){const intersection=(0,_math.add)((0,_math.divide)((0,_math.multiply)((0,_math.subtract)(xj,xi),(0,_math.subtract)(y,yi)),(0,_math.subtract)(yj,yi)),xi);if(x<intersection)inside=!inside}j=i}return Boolean(inside)}}exports.Polygon=Polygon;