"use strict";exports.__esModule=true;exports.Triangulator=void 0;var _polygon=require("../../geometry/polygon");var _circular=require("../../utils/circular");var _validator=require("../../utils/validator");const{validate}=new _validator.Validator("Triangulator");class Triangulator{constructor({indices,vertices}){this.indices=new _circular.CircularArray(indices);this.vertices=vertices;this.splitFaces=[];const polygon=new _polygon.Polygon(vertices.map(vertex=>vertex.toPoint()));this.normal=polygon.normal;const equals=polygon=>polygon.coplaner;validate({polygon,equals,expects:"the \"face\" to be coplaner"});if(polygon.clockwise){this.indices.reverse();this.vertices.reverse()}while(this.indices.length>2){const splitFace=this.sliceFace();if(!this.extractSplitFace(splitFace)){this.indices.current++;if(this.indices.current==this.indices.length)this.indices.current=0}}}sliceFace(centralIndex=null){const currentIndex=this.indices.current;if(centralIndex!==null)this.indices.current=centralIndex;const[i0,i1,i2]=[this.indices.previous,this.indices.current,this.indices.next];const[v0,v1,v2]=[this.vertices[i0],this.vertices[i1],this.vertices[i2]];if(centralIndex!==null)this.indices.current=currentIndex;return{indices:[i0,i1,i2],vertices:[v0,v1,v2]}}extractSplitFace({indices,vertices}){const[v0,v1,v2]=vertices;const points=[v0.toPoint(),v1.toPoint(),v2.toPoint()];const polygon=new _polygon.Polygon(points);if(polygon.signedArea(this.normal)>=0)return false;for(const i in this.vertices){const point=this.vertices[i].toPoint();if(point.equals(v0)||point.equals(v1)||point.equals(v2))continue;if(polygon.containsPoint(point)){const{vertices}=this.sliceFace(i);const points=vertices.map(vertex=>vertex.toPoint());const polygon1=new _polygon.Polygon(points);if(polygon1.signedArea(this.normal)>=0)return false}}this.splitFaces.push(indices);this.indices.remove(1);return true}}exports.Triangulator=Triangulator;