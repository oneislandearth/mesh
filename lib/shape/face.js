"use strict";exports.__esModule=true;exports.Face=void 0;var _math=require("@oneisland/math");var _plane=require("../geometry/plane");var _point=require("../geometry/point");var _direction=require("../geometry/utils/direction");var _edge=require("./edge");var _validator=require("@oneisland/validator");const{validate}=new _validator.Validator("Face");class Face extends Array{constructor([a,b,c],mesh=null){validate({a,b,c},"Number");validate({mesh},"Mesh");super(a,b,c);this.mesh=mesh}get species(){return"Face"}static get[Symbol.species](){return Array}get index(){if(!this.mesh)throw new Error(`Cannot compute the index - the face is not bound to a Mesh`);return Number(this.mesh.faces.findIndex(face=>face.equals(this)))}get a(){return this.vertices[0]}get b(){return this.vertices[1]}get c(){return this.vertices[2]}get vertices(){if(!this.mesh)throw new Error(`Cannot compute the vertices - the face is not bound to a Mesh`);return[this.mesh.vertices[this[0]],this.mesh.vertices[this[1]],this.mesh.vertices[this[2]]]}get plane(){if(!this.mesh)throw new Error(`Cannot compute the face plane - the face is not bound to a Mesh`);const normal=new _direction.Direction((0,_math.cross)((0,_math.subtract)(this.a,this.b),(0,_math.subtract)(this.c,this.b)));const scalar=(0,_math.dot)(normal,this.a);return new _plane.Plane({normal,scalar})}get normal(){if(!this.mesh)throw new Error(`Cannot compute the normal of the face - the face is not bound to a Mesh`);return this.plane.normal}get edges(){return[new _edge.Edge([this[0],this[1]],this.mesh),new _edge.Edge([this[1],this[2]],this.mesh),new _edge.Edge([this[2],this[0]],this.mesh)]}get center(){if(!this.mesh)throw new Error(`Cannot compute the face center - the face is not bound to a Mesh`);return new _point.Point((0,_math.divide)((0,_math.add)(this.a,this.b,this.c),3))}get area(){if(!this.mesh)throw new Error(`Cannot compute the face area - the face is not bound to a Mesh`);return(0,_math.toMeters)((0,_math.divide)((0,_math.norm)((0,_math.cross)((0,_math.subtract)(this.a,this.b),(0,_math.subtract)(this.a,this.c))),2))}get adjacentFaces(){if(!this.mesh)throw new Error(`Cannot compute the adjacent faces - the face is not bound to a Mesh`);return[this.findAdjacentFaceFromEdgeIndex(0),this.findAdjacentFaceFromEdgeIndex(1),this.findAdjacentFaceFromEdgeIndex(2)]}findAdjacentFaceFromEdgeIndex(edgeIndex){if(!this.mesh)throw new Error(`Cannot compute the adjacent face fom the edge index - the face is not bound to a Mesh`);const i0=edgeIndex;const i1=(edgeIndex+1)%3;const i2=(edgeIndex+2)%3;const faceIndex=this.mesh.faces.findIndex(face=>{const edgeCheck=~face.indexOf(this[i0])&&~face.indexOf(this[i1]);const otherCheck=face.indexOf(this[i2])==-1;return edgeCheck&&otherCheck});return~faceIndex?this.mesh.faces[faceIndex]:null}pointsAbove(distance){validate({distance},"Number");const planes=[this.plane.clone(),...this.adjacentFaces.map(face=>face?face.plane.clone():null)];for(const i in planes){if(planes[i])planes[i].scale(distance)}const missingAdjacentIndex=this.adjacentFaces.findIndex(v=>v===null);if(~missingAdjacentIndex){const vertexIndex=missingAdjacentIndex==0?2:missingAdjacentIndex==2?0:missingAdjacentIndex;planes[1+missingAdjacentIndex]=new _plane.Plane({normal:new _direction.Direction([0,1,0]),scalar:(0,_math.dot)([0,1,0],this.vertices[vertexIndex])})}const[planeFace,planeFaceAB,planeFaceBC,planeFaceCA]=planes;const pointA=planeFace.pointOfIntersectionWithPlanes(planeFaceAB,planeFaceCA);const pointB=planeFace.pointOfIntersectionWithPlanes(planeFaceAB,planeFaceBC);const pointC=planeFace.pointOfIntersectionWithPlanes(planeFaceBC,planeFaceCA);return[pointA,pointB,pointC]}get dihedrals(){const dihedrals=[];for(const adjacentFace of this.adjacentFaces){if(adjacentFace){const angle=(0,_math.acos)((0,_math.divide)((0,_math.dot)(this.normal,adjacentFace.normal),(0,_math.multiply)((0,_math.norm)(this.normal),(0,_math.norm)(adjacentFace.normal))));const dihedral=(0,_math.divide)((0,_math.subtract)(_math.pi,angle),2);dihedrals.push({angle:dihedral,type:"ridge"})}else{const projectedNormal=[this.normal[0],0,this.normal[2]];const angle=(0,_math.acos)((0,_math.divide)((0,_math.dot)(projectedNormal,this.normal),(0,_math.multiply)((0,_math.norm)(projectedNormal),(0,_math.norm)(this.normal))));const dihedral=(0,_math.divide)((0,_math.subtract)(_math.pi,angle),2);dihedrals.push({angle:dihedral,type:null})}}return dihedrals}get radials(){const radials=[];for(const i in this.vertices){const[i0,i1,i2]=[Number(i),(Number(i)+1)%3,(Number(i)+2)%3];const normals=(0,_math.multiply)((0,_math.norm)((0,_math.subtract)(this.vertices[i1],this.vertices[i0])),(0,_math.norm)((0,_math.subtract)(this.vertices[i2],this.vertices[i0])));const radial=(0,_math.acos)((0,_math.divide)((0,_math.dot)((0,_math.subtract)(this.vertices[i1],this.vertices[i0]),(0,_math.subtract)(this.vertices[i2],this.vertices[i0])),normals));radials.push(radial)}return radials}update([a,b,c]){validate({a,b,c},"Number");this[0]=a;this[1]=b;this[2]=c}flip(){this[0]=this[2];this[2]=this[0];this.plane.flip()}toString(){return JSON.stringify(this)}equals(face){validate({face},"Face");return this.toString()===face.toString()}contains(vertex){const match=this.vertices.filter(v=>v.toString()==vertex.toString());return Boolean(match)}}exports.Face=Face;
//# sourceMappingURL=face.js.map