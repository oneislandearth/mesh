{"version":3,"sources":["../../src/geometry/plane.js"],"names":["validate","Validator","Plane","constructor","normal","scalar","species","fromPolygon","polygon","Direction","clone","flip","scale","distance","containsPoint","point","epsilon","lineOfIntersectionWith","plane","n1","s1","n2","s2","direction","c1","c2","Line","Point","pointOfIntersectionWithPlanes","plane1","plane2","n3","s3","determinant","intersection","equals","toString","JSON","stringify"],"mappings":"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","sourcesContent":["// Import the required math functions\nimport { cross, dot, add, multiply, divide, subtract, epsilon, norm, det, transpose, isZeroes } from '@oneisland/math';\n\n// Import the required geometry modules\nimport { Line } from 'geometry/line';\nimport { Point } from 'geometry/point';\nimport { Polygon } from 'geometry/polygon';\n\n// Import the required geometry utilities\nimport { Direction } from 'geometry/utils/direction';\n\n// Import the validator utility\nimport { Validator } from '@oneisland/validator';\n\n// Define a validator for the class\nconst { validate } = new Validator('Plane');\n\n// Define a plane\nexport class Plane {\n\n  // Create a new Plane from a scalar and normal\n  constructor({ normal, scalar }) {\n\n    // Throw an error if the normal is not a Direction\n    validate({ normal }, 'Direction');\n\n    // Throw an error if the scalar is not a Number\n    validate({ scalar }, 'Number');\n\n    // Bind the normal and scalar\n    this.normal = normal;\n    this.scalar = scalar;\n  }\n\n  // Define the species\n  get species() {\n\n    // Define the species as 'Plane'\n    return 'Plane';\n  }\n\n  // Create a plane from a polygon\n  static fromPolygon(polygon) {\n\n    // Throw an error if the polygon is not a Polygon\n    validate({ polygon }, 'Polygon');\n\n    // Calculate the normal of the Plane\n    const normal = new Direction(cross(subtract(polygon[1], polygon[0]), subtract(polygon[2], polygon[0])));\n\n    // Calculate the scalar of the Plane\n    const scalar = dot(normal, polygon[0]);\n\n    // Return the Plane from the polygon\n    return new Plane({ normal, scalar });\n  }\n\n  // Clone the current plane\n  clone() {\n\n    // Return a clone of the plane\n    return new Plane({ normal: this.normal, scalar: this.scalar });\n  }\n\n  // Flip the current plane\n  flip() {\n\n    // Flip the sign on the normal and scalar\n    this.normal = multiply(this.normal, -1);\n    this.scalar = multiply(this.scalar, -1);\n  }\n\n  // Scale the plane from a distance\n  scale(distance) {\n\n    // Throw an error if the distance is not a Number\n    validate({ distance }, 'Number');\n\n    // Scale the plane by a distance\n    // this.scalar = add(this.scalar, multiply(distance, norm(this.normal)));\n    this.scalar = add(this.scalar, distance);\n  }\n\n  // Check if the plane contains a point\n  containsPoint(point) {\n\n    // Determine if the plane contains a point\n    return (subtract(this.scalar, dot(this.normal, point)) <= epsilon);\n  }\n\n  // Calculate the line of intersection with another plane\n  lineOfIntersectionWith(plane) {\n\n    // Throw an error if the plane is not a Plane\n    validate({ plane }, 'Plane');\n\n    // Extract the normal and scalar values from the planes\n    const [n1, s1] = [this.normal, this.scalar];\n    const [n2, s2] = [plane.normal, plane.scalar];\n\n    // Calulate the direction of the line of intersection\n    const direction = cross(n1, n2);\n\n    // Return if the planes are parallel as there is no intersection\n    if (isZeroes(direction)) return null;\n\n    // C1 and C2 are two constants that form the first point of the line\n    const c1 = divide(subtract(s1, multiply(s2, dot(n1, n2))), subtract(1, multiply(dot(n1, n2), dot(n1, n2))));\n    const c2 = divide(subtract(s2, multiply(s1, dot(n1, n2))), subtract(1, multiply(dot(n1, n2), dot(n1, n2))));\n\n    // Every line has a point and a direction, the point locates where in space the line is and the direction obviously gives the direction that the line points in\n    const point = add(multiply(c1, n1), multiply(c2, n2));\n\n    // Return the line of intersection with another plane\n    return new Line({ \n\n      // Add the point\n      point: new Point(point),\n\n      // Add the direction\n      direction: new Direction(direction)\n    });\n  }\n\n  // Calculate the point of intersection with two planes\n  pointOfIntersectionWithPlanes(plane1, plane2) {\n\n    // Throw an error if plane1 and plane2 are not a Plane\n    validate({ plane1, plane2 }, 'Plane');\n\n    // Extract the normal and scalar values from the planes\n    const [n1, s1] = [this.normal, this.scalar];\n    const [n2, s2] = [plane1.normal, plane1.scalar];\n    const [n3, s3] = [plane2.normal, plane2.scalar];\n\n    // Calculate the determinant of the normals from the planes\n    const determinant = det(transpose([n1, n2, n3]));\n\n    // Check if there no intersection and if so return false\n    if (isZeroes(determinant)) return null;\n\n    // Calculate the point of intersection from the planes\n    const intersection = divide(add(multiply(s1, cross(n2, n3)), add(multiply(s2, cross(n3, n1)), multiply(s3, cross(n1, n2)))), determinant);\n    \n    // Return the point of intersection\n    return new Point(intersection);\n  }\n\n  // Check if two planes are the same\n  equals(plane) {\n\n    // Throw an error if the plane is not a Plane\n    validate({ plane }, 'Plane');\n\n    // Return whether or not the planes are the same\n    return (this.toString() == plane.toString());\n  }\n\n  // Cast the plane to a string\n  toString() {\n\n    // Cast the plane to a string [norm(x), norm(y), norm(z), scalar]\n    return JSON.stringify([...this.normal, this.scalar]);\n  }\n}"],"file":"plane.js"}